创建一个C#的控制台项目，编写一个关于使用同步和异步方法对于性能的影响的程序。

问题4：
问题1: 为什么顺序执行时间约等于所有延迟之和(~6000ms)？
🇷🇺 Русский:
При последовательном выполнении каждый запрос ожидает завершения предыдущего перед началом. Время складывается: 2000 мс (пользователь) + 3000 мс (заказы) + 1000 мс (реклама) = 6000 мс.
🇨🇳 中文:
顺序执行时，每个请求必须等待前一个请求完成才能开始。时间累加：2000毫秒（用户数据）+ 3000毫秒（订单数据）+ 1000毫秒（广告数据）= 6000毫秒。

问题2: 为什么并行执行时间由最慢的操作决定(~3000ms)？
🇷🇺 Русский:
При параллельном выполнении все три запроса запускаются одновременно. Общее время определяется самой долгой операцией (GetUserOrdersAsync - 3000 мс), так как мы ждем завершения всех задач с помощью Task.WhenAll.
🇨🇳 中文:
并行执行时，三个请求同时启动。总时间由最慢的操作决定（GetUserOrdersAsync - 3000毫秒），因为我们使用 Task.WhenAll 等待所有任务完成。

问题3: await Task.Delay(2000) vs Thread.Sleep(2000) 的区别
🇷🇺 Русский:

Thread.Sleep(2000): БЛОКИРУЕТ поток выполнения. Поток простаивает и не может выполнять другую работу.
await Task.Delay(2000): НЕ БЛОКИРУЕТ поток. Поток освобождается и может обрабатывать другие запросы.

Для серверов критично: блокировка потоков резко снижает пропускную способность (throughput), так как количество потоков ограничено.
🇨🇳 中文:

Thread.Sleep(2000): 阻塞执行线程。线程闲置，无法执行其他工作。
await Task.Delay(2000): 不阻塞线程。线程被释放，可以处理其他请求。

对服务器至关重要： 阻塞线程会大幅降低吞吐量（throughput），因为线程数量有限。

问题4: Task 在 TPL 中的作用和 Task.WhenAll 的用途
🇷🇺 Русский:

Task: Представляет асинхронную операцию. Это "обещание" (promise) результата, который будет доступен в будущем.
Task.WhenAll: Создает задачу, которая завершается только когда завершены ВСЕ переданные задачи. Позволяет эффективно ждать завершения множества параллельных операций.

🇨🇳 中文:

Task: 代表一个异步操作。它是对未来将可用的结果的"承诺"（promise）。
Task.WhenAll: 创建一个任务，只有当所有传入的任务都完成时才完成。允许高效地等待多个并行操作完成。