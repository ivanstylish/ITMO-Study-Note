основные косяки:
1) 8 сущностей по заданию - это 8 сущностей, а не 8 таблиц
2) на схеме должна быть даталогическая модель
3) связи нужно рисовать в правильную сторону
4) у внешних ключей не бывает тип данных serial
5) в 3 задании - надо не все таблицы кое-как, а всего 3 (именно те, которые для отношения М-М), должны быть ограничения (not null например), типа данных правильные
6) в запросах - с join-ом многие справились, хотя тоже on - забываете, но с all - меньше половины. И если написано что нужно задание само, то одного select-а мало, надо написать что он делать должен

主要障碍
1) 任务中的 8 个实体是 8 个实体，而不是 8 个表
2) 图表上应该有一个数据模型
3) 应按正确的方向绘制链接
4) 外键没有序列数据类型
5) 在第三项任务中--有必要不以某种方式制作所有表，而只制作 3 个表（正是 M-M 关系表），应有限制（例如不为空），数据类型正确。
6) 在查询中--很多人都会用到连接，虽然也会用到--你忘了，但是用到的都是--不到一半。 如果写的是你需要一个任务本身，那么一个选择是不够的，你应该写它应该做什么


-----------------------------


1) 8 адекватных сущностей, которые потом во втором вопросе не превращаются в связи, уменьшая количество сущностей. Лучше придумать 9 на всякий случай. Они должны быть связаны между собой и с предметной областью. Достаточно перечисления сущностей с указанием ключей и атрибутов (можно без типов данных). Желательно хотя бы кратко пояснить, что это такое (для не совсем очевидных вариантов).
+ Написать, связь между чем и чем будет типа М-М (и это не должна быть одна из сущностей, потому что надо выбрать - сущность это или связь). По заданию - не менее 8 сущностей И (не или, и не в том числе) - не менее одной связи М-М

2) Нарисовать схему даталогической модели. Должны быть указаны типы данных, PK и FK. Правильные типы данных, которые есть в PostgreSQL, просто char без цифры в скобках - это ОДИН символ, а не строка. serial - это не int. 
Правильно нарисованные связи (в нужную сторону, а не куда попало), нет связей М-М между таблицами, На концах связей желательно 2 значка (кардинальность (1 или М) и обязательность (минимум 1 или минимум 0).  Просто линии - не годится. Схема должна соответствовать заданию 1 (те же сущности)

3) 3 штуки CREATE TABLE с правильными типами данных, serial только для первичных ключей, с правильным порядком названия поля и типа данных, с указанием NOT NULL, PRIMARY KEY, REFERENCE_S_ (без FROM и без ON). Это должны быть не произвольные, а именно те таблицы, между которыми есть связь М-М вместе с промежуточной таблицей, реализующей эту связь

4) Запрос, желательно релевантный, хоть как-то нужный в данной предметной области. Сначала само задание (Что должен сделать запрос (текстом)), а потом - сам запрос, в котором не забыли для JOIN-a ON или USING, для таблиц где надо - AS, таблицы для JOIN должны быть как-то связаны по идее. Для ALL - посмотрите, как его использовать - после ALL в скобках не все, что угодно можно ставить. 

2 и 3 задания - более важные, за них больше баллов )  

1) 8 个适当的实体，这样在第二个问题中就不会变成链接，从而减少了实体的数量。 为了以防万一，最好提出 9 个实体。 这些实体必须相互关联，并与主题领域相关。 用键和属性对实体进行枚举就可以了（没有数据类型也可以）。 最好至少简要说明这些是什么（对于不太明显的选项）。
+ 写出 M-M 类型的 "什么 "和 "什么 "之间的关系（它不应是实体之一，因为您必须选 择它是实体还是关系）。 根据作业要求--至少 8 个实体和（不是或，也不包括）--至少一个 M-M 关系。

2) 绘制数据模型图。 必须指定数据类型、PK 和 FK。 PostgreSQL 的正确数据类型是简单的 char，括号中没有数字--它是一个字符，而不是字符串。 serial 不是 int。
正确绘制链接（方向要正确，不能随处乱画），表之间不能有 M-M 链接，链接两端最好有 2 个图标（cardinality（1 或 M）和 binding（最小 1 或最小 0））。  只有线条是不行的。 模式应与任务 1 相对应（相同的实体）

3) 3 个具有正确数据类型的 CREATE TABLE，主键为序列，字段名和数据类型顺序正确，指定 NOT NULL、PRIMARY KEY、REFERENCE_S_（不含 FROM 和 ON）。 这些不应该是任意的，而应该是那些存在 M-M 关系的表，以及实现这种关系的中间表。

4) 查询，最好是相关的，至少是在给定主题领域需要的。 首先是任务本身（查询应做什么（文本）），然后是查询本身，在查询中不要忘了在必要时对表进行 JOIN（连接）或 USING（使用）。 对于 ALL - 请看如何使用它 - 在 ALL 之后的括号中不能放入所有内容。

для исключения разночтений рекомендую придумать 8 сущностей и любые две из них должны быть связаны связью М-М, не являющейся одновременно сущностью, входящей в эти 8  
为避免混淆，我建议提出 8 个实体，其中任何两个实体都必须通过 M-M 关系连接，而这种关系同时又不是这 8 个实体中的一个实体。  

в общем в первом вопросе не надо так много писать, там в задании - В ответе указать: названия сущностей, между какими сущностями есть связь многие-ко-многим, ER-модель рисовать не нужно.  
一般来说，在第一个问题中，你不需要写那么多，在任务中--在答案中指定：实体名称，实体之间是多对多的关系，ER 模型不需要绘制。  

От меня: писать все типы данных тоже не нужно, достаточно как-то так: student (id - PK, name, surname, birth_date)  
我认为：您也不需要写出所有数据类型，像这样就足够了：student (id - PK, name, surname, birth_date)

-----------------------------------------

#### 主题：宿舍  
1. 实体：

Студент(student) (id, ФИО, дата_заселения, (FK)id_комнаты) - ключ: id

Комната(room) (id, номер, этаж, (FK)id_общежития) - ключ: id

Общежитие(dormitory) (id, адрес, название) - ключ: id

Персонал(worker) (id, должность, ФИО) - ключ: id

Заявка_на_ремонт(Request_for_repair) (id, описание, дата, (FK)id_комнаты, id_сотрудника) - ключ: id

Оборудование(equipment) (id, название, (FK)id_комнаты) - ключ: id

Курс_обучения(course) (id, название, длительность) - ключ: id

Посещение(visit) (id, дата, (FK)id_гостя, (FK)id_студента) - ключ: id

Гость(guest) (id, ФИО, паспорт) - ключ: id

Связь M-M: Студенты-Курсы (один студент может посещать много курсов, один курс могут проходить много студентов)  
M-M 联系：学生-课程（一名学生可以选修多门课程，一门课程可以由多名学生选修）

2. 数据模型



3. DDL 建表
```sql
-- Студент (основная таблица)
CREATE TABLE Student (
    id SERIAL PRIMARY KEY,
    full_name VARCHAR(100) NOT NULL,
    room_id INT NOT NULL REFERENCES Room(id)
);

-- Курс_обучения (основная таблица)
CREATE TABLE Course (
    id SERIAL PRIMARY KEY,
    name VARCHAR(50) NOT NULL UNIQUE,
    duration INT CHECK (duration > 0)
);

-- Связь M-M (промежуточная)
CREATE TABLE Student_Course (
    student_id INT NOT NULL REFERENCES Student(id),
    course_id INT NOT NULL REFERENCES Course(id),
    registration_date DATE NOT NULL DEFAULT CURRENT_DATE,
    PRIMARY KEY (student_id, course_id)
);
```

4. SQL 查询 
Задание: Найти студентов, которые посещают ВСЕ курсы, связанные с техникой безопасности.  
作业：找出选修所有安全相关课程的学生。
```sql
SELECT s.name AS s_name, r.number AS room_num
FROM Student s
JOIN Student_Course sc ON s.id = sc.student_id
JOIN Course c ON sc.course_id = c.id
JOIN Room r ON s.room_id = r.id
WHERE c.name = 'Dormitory Safety Training';
```