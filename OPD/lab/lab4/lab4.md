# [主页](../README.md)/[OPD](readme.md)/lab4

![](image.png)
地址命令下的相对寻址方式

![](image-1.png)
程序往下执行
堆栈往上增长

![](image-2.png)
`CALL`指令的执行过程

![](image-3.png)
`RET`指令的执行过程

![](image-4.png)
这个程序用来计算1到N的累加和，主要通过递归来实现。递归是子程序用来调用自身的一种编程技巧。

## Контрольные вопросы

Сделать без `RET`
адрес возврата  
`POP`(Извлечение адреса возврата в AC) + `JUMP`(Переход по адресу из AC) AC  
应该用 `POP`和`JUMP` 代替 `RET` 而且你还需要以另一种方式向子程序传递数据，比如不使用堆栈  
Замена `RET` на `JUMP` с сохранением адреса возврата в регистре  
可以使用`LD`和`ST`指令来传递数据，而不是堆栈  
Инструкции `LD` и `ST` можно использовать для передачи данных вместо стека через аккмулятор.  
在CALL命令上下将POP和PUSH命令替换

如果不支持JUMP（AC），可以通过临时寄存器中转：
POP + ST + LD + JUMP  (暂存返回地址到内存，然后从内存中读取加载到寄存器，并跳转)

命令的微指令操作（寄存器之间）
Дополнительные вопросы:

AC01
Выборка адрес
SXTB (0..7)DR  -> BR
SP + BR -> DR


D695
Выборка операнда
??
E ST
C JUMP
Исполнение
CALL 695
IP -> -(SP), 695 -> IP

DR -> br
IP -> DR
br -> IP
-(SP) -> AR SP
DR -> MEM(AR)

ADD (C)
SXTB
SP + M

AC <-> MEM(SP)

SWAP

SP -> AR
MEM(AR) -> DR
DR -> BR
AC -> DR
DR -> MEM(AR) 
BR -> AC
/// положить в др знач стека
