# [主页](../README.md)/[OPD](readme.md)/lab4

![](image.png)
地址命令下的相对寻址方式

![](image-1.png)
程序往下执行
堆栈往上增长

![](image-2.png)
`CALL`指令的执行过程

![](image-3.png)
`RET`指令的执行过程

![](image-4.png)
这个程序用来计算1到N的累加和，主要通过递归来实现。递归是子程序用来调用自身的一种编程技巧。

## Контрольные вопросы

Сделать без `RET`
адрес возврата  
`POP`(Извлечение адреса возврата в AC) + `JUMP`(Переход по адресу из AC) AC  
应该用 `POP` + `ST` + `JUMP` 代替 `RET` 而且你还需要以另一种方式向子程序传递数据，比如不使用堆栈  
PUSH命令将累加器AC的值压入堆栈。   
CALL命令将返回地址压入堆栈，然后执行子程序，子程序执行完毕后，再弹出返回地址，然后跳转到返回地址。    
首先pop命令将堆栈中的返回地址弹出，然后st命令将返回地址保存到某个临时内存中，最后ld命令将临时寄存器中的值加载到AC中，然后jump命令跳转到返回地址。  
Команда PUSH положит значение аккумулятора AC в стек.  
Команда CALL положит в стек адрес возврата, затем выполняет подпрограмму, после выполнения подпрограммы раскрывает адрес возврата, а затем переходит по адресу возврата.  
Сначала команда POP выводит адрес возврата на стек, затем команда ST сохраняет адрес возврата во временной памяти, и, наконец, команда LD загружает значение из временного регистра в AC, а затем команда JUMP переходит на адрес возврата.  
Замена `RET` на `JUMP` с сохранением адреса возврата в регистре  
可以使用`LD`和`ST`指令来传递数据，而不是堆栈  
Инструкции `LD` и `ST` можно использовать для передачи данных вместо стека через аккмулятор.  
在CALL命令上下将POP和PUSH命令替换

PUSH POP ST JUMP

如果不支持JUMP（AC），可以通过临时寄存器中转：
POP + ST + LD + JUMP  (暂存返回地址到内存，然后从内存中读取加载到寄存器，并跳转)

命令的微指令操作（寄存器之间）
Дополнительные вопросы:

AC01
Выборка адрес
SXTB (0..7)DR  -> BR
SP + BR -> DR


D695
Выборка операнда
??
E ST
C JUMP
Исполнение
CALL 695
IP -> -(SP), 695 -> IP

DR -> br
IP -> DR
br -> IP
-(SP) -> AR SP
DR -> MEM(AR)

ADD (C)
SXTB
SP + M

AC <-> MEM(SP)

SWAP

SP -> AR
MEM(AR) -> DR
DR -> BR
AC -> DR
DR -> MEM(AR) 
BR -> AC
/// положить в др знач стека


66D	0800	POP	(SP)+ -> AC Загрузка результата в аккумулятор
66E	CE01	JUMP IP+1	Переход по адресу из AC 


那张图片是我用报告中下面改动后的子程序加原先的主程序的运行结果，其中用到了POP ST 和 JUMP 的组合，但是我指定的1EC地址最终只保存着第一次返回的地址的1D5然后1EB保存最终结果的地址应保存FF48但却是0000，我在想会不会有可能RET命令中的微指令寄存器之间的运行关系是SP ->AR, MEM(AR) -> DR, DR -> IP, SP+1->SP, 与这些顺序有关？莫非我需要改变组合的顺序？
66D: 0800 POP ; (SP)+ -> AC (获取返回地址并调整SP) 66E: C000 JUMP (AC) ; 间接跳转到AC中的地址我尝试用了这个方法但是1EB还是保存0000，为什么用C000？没有寻址模式，没有偏移量？这个图片包括了寻址模式