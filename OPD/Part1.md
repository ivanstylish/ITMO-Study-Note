# [主页](../README.md)/[OPD](readme.md)/OPD Part 1

### 1.3 Система команд базовой ЭВМ 基础计算机的指令系统
Классификация команд. БЭВМ способна исполнять точно определённый набор команд. При составлении программы пользователь ограничен этими командами. Полный перечень команд базовой ЭВМ приведён в таблице В.3. В зависимости от особенностей выполнения различных операций в БЭВМ команды можно разделить на четыре группы:  
指令分类。计算机能够执行一组特定的指令。在编写程序时，用户受到这些指令的限制。基础计算机的完整指令集列于表B.3中。根据在基础计算机中执行不同操作的特性，指令可以分为四类：  
- безадресные команды;  
  无地址指令;  
- команды ввода-вывода;  
  输入输出指令;  
- адресные команды;  
  地址指令;  
- команды ветвления.  
  分支指令。  

Выбор одного из типов команды осуществляется МПУ при помощи анализа старших четырех бит кода команды (биты с 12 по 15), которые называются кодом операции (КОП, Opcode - Operation code). Разработчики БЭВМ выбрали шесть форматов 16-битовых (однословых) команд с 4-битовым кодом операции (рис. В.2).  
通过分析指令代码的高四位（位12到15），微处理器选择一种指令类型，这些高四位称为操作码（КОП, Opcode - Operation code）。基础计算机的设计者选择了六种16位（单词）指令格式，每种指令都有4位操作码（见图B.2）。  
![](/OPD/Picture/1.3.B.2.png)

**Безадресные команды** выполняют различные действия без ссылок на ячейку памяти. Например, команда `CLA` предписывает ЭВМ очистить аккумулятор (записать в AC код нуля). Это команда обработки операнда, расположенного в конкретном месте, "известном" машине. Другой пример безадресной команды - команда `HLT`. Формат команды состоит из значения 0 в КОП и расширения кода операции (биты 0-11), которое задает необходимую операцию без использования явного указания ячейки памяти. Следует отметить, что безадресные операции могут использовать ячейки памяти неявно, например, команды `POP` или `RET`.  
**无地址指令** 执行各种操作而不引用内存单元。例如，指令 `CLA` 指示计算机清除累加器（将零代码写入AC）。这是一个处理操作数的指令，位于机器“已知”的特定位置。另一个无地址指令的例子是 `HLT` 指令。指令格式由操作代码中的0值和操作码扩展部分（位0-11）组成，它定义了无需明确指定内存单元的操作。值得注意的是，无地址操作可以隐式使用内存单元，例如 `POP` 或 `RET` 指令。  

**Команды ввода-вывода** управляют обменом данными между процессором и внешними устройствами ЭВМ. Эти команды будут подробно рассмотрены в части 2.  
**输入/输出指令** 控制处理器与计算机外部设备之间的数据交换。这些指令将在第2部分详细讨论。  
![](/OPD/Picture/1.3.B.3.png)

**Примечания**:  
**注释**：  
1. Значения в столбцах признаков результатов показывают, как изменится соответствующий признак в результате выполнения операции. «–» - команда не влияет на признак, «0» - признак сбросится, «*» - значение признака установится по результату операции.  
结果标志列中的值表示执行操作后相应标志将如何变化。“–” 表示指令不影响标志，“0” 表示标志将被重置，“*” 表示根据操作结果设置标志值。  

**Адресные команды** предписывают машине производить действия с ячейкой памяти, адрес которой определяется исходя из адресной части команды, состоящей из 12 бит (биты 0..11). КОП (биты 12..15) принимает значения от 0x2 до 0xE и задает операцию.  
**地址命令**指示机器对内存单元执行操作，该内存单元的地址由命令的地址部分确定，地址部分由12位组成（位0..11）。COP（位12..15）取值从0x2到0xE并定义操作。  

**Команды ветвления** позволяют продолжить вычислительный процесс с другого адреса программы в зависимости от состояния признаков результата NZVC.  
**分支命令**允许根据NZVC结果标志的状态从另一个程序地址继续计算过程。  

**Режимы адресации в адресных командах**. Для адресных команд предусмотрено два различных формата:  
**地址命令中的寻址模式**。 地址命令提供了两种不同的格式：  

1. **С прямой абсолютной адресацией** (рис. В.2.б) — в бите 11 у этих команд всегда 0, а в адресной части (битах с 0 по 10) записано абсолютное значение адреса операнда (т.е. номер ячейки в адресном пространстве) в памяти. При выполнении операции команда непосредственно обращается по заданному адресу выбирая или записывая операнд.  
**使用直接绝对寻址**（图B.2.b）——在这些命令中，位11总是0，并且在地址部分（位0到10）中记录了操作数地址的绝对值（即地址空间中的单元编号）在内存中。执行操作时，命令直接访问指定地址以读取或写入操作数。  

1. **С относительной адресацией** (рис. В.2.г)— 11-й бит содержит 1, а биты 8-10 режим адресации. В биты 0-7 записано смещение, которое используется для вычисления адреса операнда в памяти с помощью прибавления смещения к значению 1Р. Смещение может быть и положительным и отрицательным, позволяя адресовать 127 ячеек до и 128 ячеек после текущей команды в памяти. Подчеркнем, что смещение 0 будет указывать на следующую за командой ячейку. Это происходит потому, что к моменту вычисления адреса операнда, счетчик команд уже увеличен на 1 в результате исполнения команды. Режимы адресации могут быть:  
**使用相对寻址**（图B.2.g）——第11位包含1，第8-10位表示寻址模式。第0-7位存储偏移量，用于通过将偏移量加到IP的值来计算内存中操作数的地址。偏移量可以是正数或负数，允许在内存中对当前指令前127个单元和后128个单元进行寻址。值得强调的是，偏移量为0将指向紧随指令之后的单元。这是因为在计算操作数地址时，指令计数器已经因为执行指令而增加了1。寻址模式可以是：  

   - Прямая относительная (код 0xE) или еще ее называют «прямая со смещением относительно IP». Адрес операнда получается сложением закодированного в команде смещения со счетчиком команд.  
     直接相对寻址（代码 0xE），也称为“相对 IP 的直接寻址”。操作数的地址通过将命令中的编码偏移量与指令计数器相加获得。  
   - Косвенная относительная (0x8). Косвенная адресация подразумевает, что в ячейке памяти, которая вычисляется из адресной части команды через сложение смещения со счетчиком команд, хранится адрес операнда. В результате после вычисления ячейки, где хранится адрес, ее значение снова используется в качестве адреса, вычисляя расположение операнда в памяти.  
     间接相对寻址（0x8）。间接寻址意味着在通过将偏移量与指令计数器相加来计算的命令地址部分的内存单元中，存储着操作数的地址。结果是，在计算存储地址的内存单元后，其值再次用作地址，用于计算操作数在内存中的位置。  

   - Косвенная автоинкрементная (0xA). Эта адресация аналогична случаю косвенной адресации, однако `после` загрузки операнда из памяти, значение адреса в ячейке памяти увеличивается на 1. Режим обычно удобно использовать для обработки элементов массива, заданных начальным адресом и длиной в порядке возрастания порядкового номера элементов.  
     间接自动增量寻址（0xA）。这种寻址类似于间接寻址，但在从内存加载操作数之后，内存单元中的地址值增加 1。通常使用这种模式来处理由初始地址和长度按元素顺序递增的数组元素。  

   - Косвенная автодекрементная (0xB). Эта адресация аналогична случаю косвенной адресации, однако `перед` загрузкой операнда из памяти, значение адреса в ячейке памяти уменьшается на 1. Режим обычно удобно использовать для обработки элементов массива, заданных начальным адресом и длиной в порядке убывания порядкового номера элементов.  
     间接自动减量寻址（0xB）。这种寻址类似于间接寻址，但在从内存加载操作数之前，内存单元中的地址值减少 1。通常使用这种模式来处理由初始地址和长度按元素顺序递减的数组元素。  
  
   - Со смещением относительно SP (0xC). Адрес операнда получается сложением закодированного в команде смещения с указателем стека. Режим позволяет адресовать параметры с заданным номером, которые находятся в стеке.  
     相对 SP 的偏移寻址（0xC）。操作数的地址通过将命令中的编码偏移量与堆栈指针相加获得。该模式允许寻址堆栈中具有指定编号的参数。  

   - С непосредственной (прямой) загрузкой операнда (0xF) в аккумулятор (рис. В.2д). Для такого формата биты 8-11 установлены в единицы. Команда с режимом адресации «прямая загрузка» по факту не является адресной, а только использует формат адресной команды. Она берет число в битах 0-7 команды в качестве операнда и рассматривает его как знаковое, расширяя знак байта (бит 7) в биты 8-15 старшего байта.   
   Сводная информация о режимах адресации приведена в табл.В.10.  
     直接加载操作数到累加器（代码 0xF）（见图 В.2д）。对于这种格式，比特 8-11 被设置为1。采用“直接加载”寻址模式的命令实际上不是地址模式，而只是使用地址命令的格式。它将命令中比特 0-7 的数字作为操作数，并将其视为符号数，将符号位（比特 7）扩展到高字节的比特 8-15。  
     寻址模式的汇总信息在表 В.10 中给出。  

### 1.4 Представление данных в БЭВМ 基础计算机中数据的表示
Архитектура фон-Неймана предполагает использование общей памяти для данных и команд. При этом в ячейках памяти просто хранятся числовые значения, а их интерпретация ложится на разработчика программ для ЭВМ. Интерпретация значения, содержащегося в ячейке памяти называется областью преставления
данных (ОП). Не зная, как организованна программа в памяти, как она использует значения разрядов слова той или иной ячейки, очень сложно интерпретировать ее
содержимое. Например, значение ячейки ${3021}_{16}$ может быть кодом команды `OR 0x21`, беззнаковым числом ${12321}_{10}$ , двумя символами ASCII «0!», набором логических переменных, чем нибудь другим или не быть ничем, представляя собой случайный набор бит в памяти после включения ЭВМ.  
冯·诺依曼架构假设使用统一的内存来存储数据和指令。在这种情况下，内存单元中仅存储数值，而它们的解释则由计算机程序开发人员负责。对内存单元中包含的值的解释称为数据表示域（ОП）。如果不知道程序在内存中的组织方式，以及它如何使用某个内存单元中某个字的位值，就很难解释其内容。例如，内存单元的值 ${3021}_{16}$ 可能是指令代码OR 0x21，无符号数 ${12321}_{10}$ ，两个ASCII字符“0!”，一组逻辑变量，或者其他任何东西，也可能什么都不是，只是计算机开机后内存中的随机位集合。  

Количество использованных бит памяти, совместно с областью
представления, задает область допустимых значений (ОДЗ) для данных, которые мы, как разработчики программы, размещаем в оперативной памяти. ОДЗ применяется в вычислительной технике по аналогии с алгеброй.  
使用的内存位数与表示域（ОП）共同确定了我们作为程序开发人员在内存中存放的数据的可允许值域（ОДЗ）。在计算机科学中，ОДЗ的概念类似于代数学中的值域。  

В любой ЭВМ в ячейке памяти можно хранить данные различных типов ——
числа с фиксированной и плавающей точкой, логические переменные, символы истроки символов, и т.д. В БЭВМ ОП и ОДЗ связаны с размером машинного слова,которое, как мы знаем, составляет 16 двоичных разрядов.  
在任何计算机中，内存单元都可以存储各种类型的数据——定点和浮点数、逻辑变量、字符和字符串等。在小型计算机中，表示域（ОП）和允许值域（ОДЗ）与机器字的大小相关联，我们知道机器字的大小是16个二进制位。  

### 1.4.1 Представление чисел в БЭВМ 基础计算机中数字的表示
16-ти разрядное машинное слово БЭВМ может быть интерпретировано как
знаковое или беззнаковое.  
16位小型计算机的机器字可以解释为有符号或无符号数。  

Если мы зафиксируем двоичную точку числа непосредственно за 0-вым
разрядом и используем все 16 разрядов машинного слова для хранения значения числа, задав тем область представления, то беззнаковое представление можно
использовать для представления нуля и натуральных чисел, не превышающих
$65535$. Подобные числа (так же как и рассмотренные ниже двоичные числа со знаком) называются числами с фиксированной точкой, разделяющей целую и дробную части числа. При размещении таких чисел в одном 16-разрядном слове они могут изменяться от ${(0000 0000 0000 0000)}_{2}$ = ${(0000)}_{16}$ = $0$ до ${(1111 1111 1111 1111)}_{2}$ =
${(FFFF)}_{16}$ = ${2}^{16}$ - $1$ = $65535$. Такая запись называется прямым колом числа.  
如果我们将数值的二进制小数点固定在第0位之后，并使用所有16位机器字来存储数值，从而定义表示域，则可以使用无符号表示来表示不超过65535的零和自然数。此类数（以及下面讨论的带符号的二进制数）称为定点数，定点数的整数部分和小数部分由固定的小数点分隔。当这些数存储在一个16位字中时，其范围可以从 ${(0000 0000 0000 0000)}{2}$ = ${(0000)}{16}$ = $0$ 到 ${(1111 1111 1111 1111)}{2}$ = ${(FFFF)}{16}$ = $2^{16} - 1$ = $65535$。这种表示法称为数值的直接编码。  

Целочисленное знаковое пресставление числа используются тогда, когда необходимо различать положительные и отрицательные числа. В современных ЭВМ для представления целых чисел со знаком используется дополнительный код, В котором старший бит формата определяет знак числа: 0 - для положительных чисел и 1 - для отрицательных чисел. При этом дополнительный код положительного числа совпадает с его прямым кодом. А для представления отрицательного числа в дополнительном коде производится инвертирование прямого кода модуля числа (получение обратного кода числа) и добавление к результату единицы. Такая же операция используется при изменении знака числа, представленного вдополнительном коде.Дополнительный код определен для любой системы счисления, включая, например,десятичную.  
有符号整数表示用于区分正数和负数。在现代计算机中，有符号整数的表示采用补码形式，其中最高位表示数的符号：0 表示正数，1 表示负数。正数的补码与其原码相同。而对于负数的表示，先对其绝对值的原码进行逐位取反（得到反码），然后对结果加1。相同的操作也用于改变以补码表示的数的符号。补码可以用于任何进位制系统，包括十进制系统。  

Итак, например, для представления числа ${-709}_{10}$ в дополнительном коде потребуется:  
以下是将 ${-709}_{10}$ 表示为补码形式的步骤：  

1. Записать прямой код модуля заданного числа:  
   直接写出给定数字的模的代码：  
```
0 000 0010 1100 0101  Модуль числа 709
```

2. Найти поразрядное дополнение для каждой цифры числа(для двоичной системы счисления это аналогично его инверсии, или замене всех 0 на 1, а всех 1 - на 0):  
   找出数字每个位的比特补码（对于二进制数系统，这类似于反转，或将所有 0 替换为 1，将所有 1 替换为 0）：  
```
1 111 1101 0011 1010  Инверсия
```

3. Прибавить единицу к полученному результату:  
   在所得结果上加 1：  
   
```  
1 111 1101 0011 1010
+                  1
—————————————————————
1 111 1101 0011 1011  Число -709 в дополнительном коде
```         

Так как перенос из старшего разряда выходит за пределы разрядной сетки, то по правилам операций со знаковыми числами в дополнительном коде, он не учитывается. Оставшаяся же 16-разрядная сумма равна нулю, что подтверждает правильность преобразования.  
由于进位从最高位溢出，按照补码形式有符号数的操作规则，它不会被考虑。剩下的16位和为零，这验证了转换的正确性。  

Использование дополнительного кода упрощает конструкцию ЭВМ, так как
при сложении двух таких чисел, имеющих разные знаки, не требуется переходить к операциям вычитания меньшего (по модулю) числа из большего и присвоения результату знака большего числа. Кроме того, одной и той же схемой сумматора можно воспользоваться для выполнения операций над знаковым и беззнаковым представлением числа. Признаком выхода за границы разрядной сетки для беззнакового представления числа является перенос в старший разряд (бит С - Саггу). Признаком переполнения разрядной сетки для знакового представления является бит переполнения (OVerflow). Рассмотрим возникновение этих ситуаций на примере представления чисел в четырехразрядной сетке (рис. В.4).  
使用补码简化了计算机的设计，因为在对两个具有不同符号的补码数进行加法时，不需要转到减法操作，即从较大的数中减去较小的数（按绝对值计算）并赋予结果较大的数的符号。此外，同一加法器电路可以用于有符号和无符号数的运算。对于无符号数，超出位数范围的标志是进位到最高位（Carry-out）。对于有符号数，超出位数范围的标志是溢出位（Overflow）。我们可以通过四位数的表示来考察这些情况（见图V.4）。  
![](/OPD/Picture/1.4.B.4.png)

Процессор определяет переполнение по следующему правилу: если поразрядные переносы в знаковый и из знакового разряда одновременно отсутствуют или присутствуют - значит переполнения нет, если присутствует только в одном - значит переполнение знаковой разрядной сетки есть. Для приведенного примера знаковый разряд имеет номер 3, для слова БЭВМ — номер 15.  
处理器通过以下规则来确定是否发生了溢出：如果符号位和从符号位传出的进位同时不存在或同时存在，则表示没有溢出；如果只有一个存在，则表示发生了有符号数的溢出。在给出的例子中，符号位的编号是3，对于16位的机器字，则是15。  

Разрядная сетка слова, с которой БЭВМ выполняет операции, состоит из 16 разрядов. Если необходимо более высокая разрядность числа, то при помощи команды учета переноса при сложении (`АОС`) возможны операции с 32-х разрядными числами и числами более высокой разрядности. В зависимости от необходимого представления числа программист должен учитывать максимальное и минимальное значение для используемых чисел.  
机器字的位数，现代计算机执行操作时为16位。如果需要更高的位数，可以通过使用进位处理指令（`AOC`）来进行32位及更高位数的数值操作。根据所需的数值表示，程序员必须考虑所使用数值的最大值和最小值。  

БЭВМ не умеет на уровне машинных команд работать с числами с плавающей точкой. Представление логической и символьной информации не отличаются от современных ЭВМ и выходят за рамки данных методических указаний.  
小型计算机在机器指令级别不支持浮点数操作。逻辑信息和字符信息的表示与现代计算机类似，超出了本方法指导的范围。  

### 1.5 Операции с памятью и арифметические операции 内存运算和算术运算
Как мы уже говорили, БЭВМ относится к процессорам аккумуляторного типа, в которых один операнд находится в ячейке памяти, а второй в регистре общего назначения AC. Для осуществления передачи значений между AC и памятью предназначено несколько операций, которые выполняются с учетом выбранного режима адресации.  
如前所述，BЭВМ（Большая Электронно-Вычислительная Машина）大型计算机属于累加器类型的处理器，其中一个操作数位于存储单元中，另一个操作数位于通用寄存器AC中。为了实现AC和内存之间的值传输，设计了若干操作，这些操作根据所选的寻址模式进行

Загрузка значения для обработки или вычислений из ячейки памяти в аккумулятор производится при помощи команды `LD`. Сохранение результата производится командой `ST`. При необходимости, можно выполнить обмен содержимого ячейки памяти и аккумулятора при помощи команды `SWAM`.  
使用`LD`命令从内存单元加载值到累加器中进行处理或计算。结果保存使用`ST`命令。如果需要，可以使用`SWAM`命令交换内存单元和累加器的内容。

Обмен старшего и младшего байтов 16-ти разрядного (двухбайтового) AC между собой бывает необходим в программах, работающих, например, со строками. Для этого предназначена команда `SWAB`.  
16位（双字节）AC的高字节和低字节之间的交换在某些程序（例如处理字符串的程序）中是必要的。为此，使用SWAB命令。

Сложение целых двоичных чисел со знаком и без знака выполняется в базовой ЭВМ с помощью команды `ADD`. Для учета переноса из младших слов многословных (32 разряда и более) чисел необходимо использовать команду `ADC`.  
带符号和无符号的二进制整数的加法在基本计算机中使用ADD命令进行。为了考虑从多字（32位及以上）数的低字传递，需要使用ADC命令。

Увеличение на 1 (Increment) и уменьшение на 1 (Decrement). По команде `INC` к содержимому аккумулятора прибавляется единица, а по команде `DEC` - единица вычитается. Если при этом возникает перенос из старшего разряда AC, то в признак переноса заносится 1, в противном случае в него заносится 0, аналогичным образом обрабатывается переполнение. Исторически, в процессорах команды `INC` и `DEC` реализовывались быстрее, чем сложение с единицей или ее вычитание. В современных процессорах эта разница практически отсутствует за счет архитектурных оптимизаций.  
增加1（Increment）和减少1（Decrement）。INC命令将1加到累加器内容中，而DEC命令将1减去。如果此时出现从AC高位的进位，则进位标志设为1，否则设为0，溢出也按类似方式处理。历史上，处理器中的INC和DEC命令实现速度比加1或减1更快。在现代处理器中，由于架构优化，这种差异几乎不存在。

Изменение знака числа производится при помощи команды `NEG`, которая является удобным сокращением от `NOT`+`INC`.  
改变数值的符号可以使用NEG命令，它是NOT+INC的简写。

Расширение знака осуществляется при помощи команды `SXTB`. Она используется в случаях, когда в АС записано знаковое 8-ми разрядное число, и его
для последующей арифметической операции в АЛУ, необходимо превратить в знаковое 16-ти разрядное знаковое число. Для этого разряд с номером 7 операнда команды (находится в АС) копируется в разряды с 8 по 15 результата (тоже в АС).  
扩展符号通过指令 `SXTB` 实现。它在累加器中存储了一个符号的 8 位数字时使用，目的是将其扩展为一个符号的 16 位数字，以便进行后续的算术操作。在此过程中，操作数（存储在累加器中）的第 7 位被复制到结果的第 8 位到第 15 位（也在累加器中）。

Для выполнения вычитания (X-Y) в базовой ЭВМ предусмотрена команда `SUB Y`. Например, вычитание X-Y реализуется командами `LD X`, `SUB Y`. Команда вычитания с заемом (по аналогии с `АDC`) в БЭВМ не реализована.  
在基本计算机中，执行减法（X-Y）时，使用 `SUB Y` 指令。例如，减法 X-Y 可以通过以下指令实现：`LD X` 和 `SUB Y`。基本计算机中没有实现带借位的减法指令（类似于 `ADC`）。

Сравнение чисел выполняется командой `СМР` аналогично вычитанию, однако результат вычитания АС-М в АС не сохраняется, по нему лишь устанавливаются признаки результатов NZVC.  
数字比较由 "CMR "命令执行，方法与减法相同，但不存储 AC-M 中的减法结果，只确定 NZVC 结果的符号。

Умножение и деление. В базовой ЭВМ нет команд для выполнения этих действий (АЛУ не выполняет таких операций). Поэтому произведение, частное либо остаток от деления необходимо получать программным путем.
乘法和除法。在基本计算机中，没有用于执行乘法和除法的指令（算术逻辑单元不支持这些操作）。因此，乘积、商或除法的余数需要通过程序实现。

Команды `ASR` и `ASL` (арифметические сдвиги вправо и влево) осуществляют деление и умножение на 2. Их последовательным использованием можно организовать умножение и деление на число, которое представлено степенью 2,например на 2,4,8,16...  
指令 `ASR` 和 `ASL`（分别是算术右移和左移）实现了除以 2 和乘以 2 的操作。通过连续使用这些指令，可以实现对一个数字按 2 的幂进行乘法或除法，例如 2、4、8、16 等。

### 1.6 Сдвиги и логические операции 移位和逻辑运算
Побитовая обработка данных обеспечивается базовой ЭВМ командами логического сложения и умножения, циклических сдвигов, а также командами инвертирования и очистки аккумулятора и регистра переноса.  
数据位处理通过逻辑加法和乘法、循环移位命令以及反转、清除累加器和移位寄存器的命令来实现。

Логическое умножение (команда `АND`) выполняет над каждым разрядом содержимого аккумулятора и содержимым ячейки памяти, заданной адресной частью команды, операцию логического умножения ("И"). Результат выполнения
команды для каждой пары битов операндов равен единице только тогда, когда оба бита равны единице, а в остальных случаях бит результата равен нулю, т.е., например, команда позволяет выделять или очищать определенные биты слова.  
逻辑与运算（指令 `AND`）对累加器的每一位与指令地址部分指定的内存单元的内容进行逐位逻辑与操作。该操作的结果如下：对于操作数的每一对比特位，结果位仅在两个比特位都为 1 时为 1；在其他情况下，结果位为 0。例如，这条指令允许选择或清除字中的特定位。

Логическое сложение (команда `OR`) выполняет над каждым разрядом содержимого аккумулятора и содержимым ячейки памяти, заданной адресной частью команды, операцию логического сложения («ИЛИ»).  
逻辑加法（`OR` 指令）对累加器内容的每一位和指令地址部分指定的内存位置内容执行逻辑加法（"OR"）操作。

Циклический сдвиг влево м вправо на один разряд (команды ROL и ROP) замыкают аккумулятор и регистр переноса в кольцо и сдвигают все биты кольца на один разряд влево или вправо (рис. В.5).  
循环左移和右移（指令 `ROL` 和 `ROR`）将累加器和进位寄存器以环形方式连接，并将所有位循环移动一位，左移或右移（见图 B.5）。

Очистка аккумулятора производится при помощи команды `СLА`. Побитная инверсия или отрицание содержимого аккумулятора производится при помощи команды `NOT`. Для нее предусмотрен синоним `СМА`. Очистка м инверсия флага
переноса С производится командами `CLC` и `CMC`.  
清除累加器通过指令 `CLA` 实现。逐位取反或否定累加器的内容通过指令 `NOT` 实现，`SMA` 是它的同义词。清除和取反进位标志 C 通过指令 `CLC` 和 `CMC` 实现。

```
                  флаг C        Аккумулятор
    До сдвига               0  1011100000101011
 После сдвига влево         1  0111000001010110
 После сдвига вправо        1  0101110000010101
 Рисунок B.5  Циклические сдвиги: а - влево,б - вправо         
```

### 1.7 Управление вычислительным процессом 计算过程控制
Задача управления вычислительным процессом решается в языках высокого уровня операторами проверки условия, организацией циклических повторений, условным оператором и т. д. При этом, в зависимости от проверки условия, производится выполнение той или иной последовательности операторов, что получило название условное выполнение.  
计算过程控制任务通过高级语言中的条件检查操作符、循环重复组织、条件操作符等来解决。在这种情况下，根据条件检查的结果，执行相应的操作序列，这被称为条件执行。

В базовой ЭВМ, как и в любой другой реализации процессора, условное выполнение состоит из установки признаков результатов и изменения счетчика команд в зависимости от состояния признаков.  
在基础计算机中，如同在任何其他处理器实现中一样，条件执行包括结果标志的设置和根据标志状态更改指令计数器。 

Установка признаков результата происходит в блоке установки признаков результата, данные в который попадают из коммутатора. Анализ результата выполнения каждой машинной команды может изменять признаки, устанавливая или сбрасывая их в зависимости от получившегося числа. Некоторые команды оставляют признаки неизменными.  
结果标志的设置发生在结果标志设置块中，其数据来自交换器。每个机器指令执行的结果分析可以更改标志，根据得到的数值设置或清除它们。一些指令保持标志不变。

Например, команда `CLA` оставляет неизменным признак переноса C, сбрасывает признак переполнения V (какое переполнение может быть при сбросе значения AC в 0?), а признаки N и Z устанавливаются по результатам операции, что для операции очистки AC эквивалентно установке N в 0 (т.к. в 15 разряде для знакового представления будет 0), а Z в 1. Подробная информация о поведении каждой команды относительно изменения признаков результата после ее выполнения приведена в табл. В.З.  
例如，CLA指令保持进位标志C不变，清除溢出标志V（在AC值复位为0时会发生什么溢出？），而N和Z标志根据操作结果设置，对于清除AC的操作，相当于将N设置为0（因为符号表示的第15位将是0），而将Z设置为1。关于每个指令在执行后的结果标志变化的详细信息在表V.3中给出。

Анализ установленных признаков результата к текущему моменту и изменение счетчика команд в зависимости от результатов анализа происходит при помощи команд ветвления.  
通过分支指令对当前设置的结果标志进行分析并根据分析结果更改指令计数器。

Команды ветвления позволяют организовать нелинейное исполнение программ. Эти команды при выполнении заданного признаками NZVC условия осуществляют переход по указанному адресу (запись в IP нового адреса выполнения в программе). Если условие не выполняется, то происходит выполнение команды, которая следует за командой ветвления. КОП команды ветвления ${1111}_{2}$. Операция проверки признаков результата задается в формате команды в битах 8-11 расширения КОП (см. рис. В.2е), а смещение (биты 0..7) указывается относительно текущего (увеличенного на 1 после цикла выборки команды) значения IP, при этом сумма текущего значения IP и смещения вычисляется абсолютный адрес для перехода в адресном пространстве БЭВМ.    
分支指令允许组织程序的非线性执行。这些指令在满足NZVC标志条件时执行到指定地址的跳转（在程序中将新执行地址写入IP）。如果条件不成立，则执行紧随分支指令之后的指令。分支指令的操作码为 ${1111}_{2}$ 。结果标志检查操作在指令格式中的第8-11位扩展操作码中设置（参见图V.2e），偏移量（第0..7位）相对于当前IP值（在指令提取周期后增加1）指定，此时当前IP值与偏移量的和计算为在计算机地址空间中的绝对跳转地址。

Команды ветвления не изменяют состояния аккумулятора и признаки результата. Они могут лишь изменить содержимое счетчика команд, поместив в него адрес, определяемый значением IP и смещением.  
分支指令不改变累加器和结果标志的状态。它们只能更改指令计数器的内容，将IP值和偏移量确定的地址放入其中。

Равенство или неравенство двух чисел можно проверить, если вычесть одно из другого (можно, также, применить команду сравнения `CMP: LD Y \n CMP X`). Если X-Y == 0 то установится признак результата Z. Соответственно, команды ветвления `BEQ` и `BNE` осуществят переход в случае равенства или неравенства заданных X и Y. Таким же образом проверяется равенство X==0. Например, мы хотим проверить результат операции логического умножения на равенство 0. Команда `AND` устанавливает признаки NZ результата в зависимости от значения результата, поэтому будет достаточно выполнить последовательно команды `AND` и `BEQ`. В случае, если команда не устанавливает необходимые признаки результата (пример - `IN`), для их установки можно использовать команду `CMP #0`.  
可以通过将两个数相减来检查它们是否相等或不相等（也可以使用比较指令`CMP: LD Y \n CMP X`）。如果X-Y == 0，则设置结果标志Z。因此，分支指令`BEQ`和`BNE`在指定的X和Y相等或不相等时执行跳转。同样的方法可以检查X==0。例如，我们想要检查逻辑乘法操作的结果是否为0。`AND`指令根据结果值设置NZ标志，因此顺序执行`AND`和`BEQ`指令就足够了。如果指令未设置所需的结果标志（例如`IN`），可以使用`CMP #0`指令来设置它们。

Сравнение величин чисел можно осуществлять по различным условиям. Следует различать использование ветвлений по признакам, которые подходят для знаковых или беззнаковых чисел, а также те, которые применимы для обоих типов чисел. Для беззнаковых величин, после установки признаков (например, так: `LD Y`, `CMP X`), можно проверить командами `BLO` (переход, если X меньше по значению Y), `BHIS` (переход если X больше или совпадает с Y). Эти команды используют для решения о переходе значение флага переноса и эквиваленты `BCC` и `BCS`. Для знаковых величин подходят команды `BLT` (переход, если X < Y) и `BGE` (переход, если X >= Y), эти команды используют значение признака N и V. Для обоих также могут использоваться команды `BMT`, `BPL`, `BVS`, `BVC` (см. табл. В.3).  
可以根据不同条件比较数值的大小。应该区分适用于有符号数或无符号数的分支，以及适用于这两种数的分支。对于无符号数，在设置标志后（例如：`LD Y`, `CMP X`），可以用`BLO`指令检查（如果X小于Y的值则跳转），用`BHIS`指令检查（如果X大于或等于Y的值则跳转）。这些指令使用进位标志的值，等同于`BCC`和`BCS`指令。对于有符号数，使用`BLT`指令（如果X < Y则跳转）和`BGE`指令（如果X >= Y则跳转），这些指令使用N和V标志的值。对于两者，也可以使用`BMT`, `BPL`, `BVS`, `BVC`指令（参见表V.3）。

Команды `BCS` и `BCC` удобны тогда, когда производится побитовый анализ числа. Например, производится сдвиг `ASR` и нулевой бит выдвигается в C. Командой `BCS` можно удобно проверить, что бит был установлен.  
`BCS`和`BCC`指令在进行数的逐位分析时非常方便。例如，执行`ASR`移位，零位被送入C。可以使用`BCS`指令方便地检查位是否已设置。

Команды переходов широко применяются для организации циклических программ, которые используются в тех случаях, когда требуется несколько раз выполнить набор одинаковых действий с различными наборами данных. Базовая ЭВМ обладает рядом средств для упрощения циклических программ. К ним относятся автоинкрементные и автодекрементные режимы адресации, а также средства для организации циклических повторений.  
跳转指令广泛用于组织循环程序，当需要对不同的数据集执行多次相同的操作时使用。基础计算机具有一系列简化循环程序的工具。这些工具包括自动增量和自动减量寻址模式，以及组织循环重复的工具。

Циклы со счетчиком в БЭВМ организуются при помощи команды "Декремент и пропуск" (`LOOP`). Данная команда уменьшает заданную ячейку памяти, определяющую число повторений, и проверяет, что в ячейке еще находится положительное число. Если оно действительно положительное, то выполняется следующая после `LOOP` команда, если число отрицательно или равно нулю, то к счетчику команд добавляется единица, и следующей будет выполнена команда через одну после `LOOP`.
在大型计算机中，使用“减量和跳过”指令（`LOOP`）来组织带计数器的循环。该指令减少指定的内存单元，该内存单元确定重复次数，并检查内存单元中是否仍有正数。如果确实为正数，则执行`LOOP`之后的下一条指令；如果数为负或为零，则在指令计数器中加1，并且下一条将执行的是在`LOOP`之后的第二条指令。

Для прекращения работы программы и переход в режим, когда оператор может взаимодействовать с БЭВМ при помощи пульта, используется команда "Останов" (`HLT`). Текущая реализация этой команды закрывает вентиль, разрешающий прохождение импульсов тактового генератора на схему МПУ, тем самым останавливая выполнение программы. В современных ЭВМ такой способ не применяется.  
为了终止程序工作并进入操作员可以通过控制台与大型计算机互动的模式，使用“停止”指令（`HLT`）。当前该指令的实现是关闭允许时钟脉冲通过到MPU电路的闸门，从而停止程序的执行。在现代计算机中不再使用这种方法。

### 1.9 Выполнение машинных команд 机器指令的执行
В процессе исполнения команд устройство управления (напомним, еще его называют микропрограммным устройством управления - МПУ) БЭВМ производит пересылку команд, операндов и промежуточных результатов из одного регистра ЭВМ в другой, осуществляет анализ отдельных частей команды (кода операции и режима адресации), а также управляет АЛУ, считывает/записывает содержимое памяти или регистров устройства ввода-вывода.  
在指令执行过程中，控制装置（也称为微程序控制装置 - MPU）负责从一个计算机寄存器向另一个寄存器传送指令、操作数和中间结果，分析指令的各个部分（操作码和寻址模式），以及控制算术逻辑单元（ALU）、读取/写入内存或输入/输出设备的寄存器内容。

Эти действия называются микрооперациями, они происходят в заданной последовательности и скоординированы между собой импульсами генератора тактовых импульсов. Устройство управления хранит в себе последовательность действий для исполнения команд и выполнения пультовых операций, называемых циклами. Набор циклов, составляющих код программы МПУ, называется микрокодом или микропрограммой.  
这些操作称为微操作，它们按照指定的顺序发生，并由时钟脉冲发生器的脉冲进行协调。控制装置存储用于执行指令和执行控制台操作的一系列操作，称为循环。组成MPU程序代码的一组循环称为微代码或微程序。
![](/OPD/Picture/1.9.B.7.png)
Рисунок B.7 Циклы устройства управления.  
图 B.7 控制设备周期。

Цикл пультовых операций включает в себя выполнение соответствующих действий для выполнения пультовых операций: ввод адреса, запись, чтение, пуск.  
控制台操作循环包括执行相应的操作：地址输入、写入、读取、启动。

"Ввод адреса" записывает содержимое клавишного регистра в счетчик команд.  
"地址输入"将键盘寄存器的内容写入指令计数器。

"Запись" записывает содержимое клавишного регистра в ячейку памяти, адрес которой указан в счетчике команд, после чего увеличивает на единицу содержимое счетчика команд, т.е. переходит к следующей ячейке.  
"写入"将键盘寄存器的内容写入到指令计数器中指定地址的内存单元，然后将指令计数器的内容增加1，即转到下一个单元。

"Чтение" считывает в регистр данных содержимое ячейки памяти, адрес которой указан в счетчике команд, после чего увеличивает на единицу содержимое счетчика команд.  
"读取"将指令计数器中指定地址的内存单元内容读取到数据寄存器中，然后将指令计数器的内容增加1。

"Пуск" сбрасывает содержимое регистров DR, CR, SP, AC, BR, AR, сбрасывает признаки результата, запрещает прерывания и, если установлен режим "РАБОТА", переходит к выполнению команды, адрес которой указан в счетчике команд.  
"启动"清除DR、CR、SP、AC、BR、AR寄存器的内容，清除结果标志，禁用中断，如果设置了“工作”模式，则执行指令计数器中指定地址的指令。

На панели оператора расположены и другие органы управления — переключатель "РАБОТА/ОСТАНОВ", который вызывает останов программы после каждой команды; переключатель "ТАКТ", который может выполнить микрокод по одному такту, кнопка «Продолжение» - возобновляющая работу остановленной ЭВМ.  
在操作面板上还有其他控制装置——“工作/停止”开关，它在每条指令后停止程序；“时钟”开关，它可以逐个时钟周期执行微代码；“继续”按钮，用于恢复停止的计算机的工作。

Цикл команды. Для реализации одной команды требуется выполнить определенное количество действий, каждое из которых инициируется одним тактовым импульсом. Общее число тактовых импульсов, требуемых для выполнения команды, определяет ее выполнение, называемое циклом команды. Цикл команды включает несколько машинных циклов: выборки команды, выборки адреса, выборки операнда, исполнения и прерывания (рис. В.7). Основные действия, выполняемые ЭВМ во время каждого из машинных циклов, проиллюстрированы и описаны ниже на примере команды `ADD`.  
指令循环。执行一条指令需要完成一定数量的操作，每个操作由一个时钟脉冲启动。执行指令所需的总时钟脉冲数决定了指令的执行，称为指令循环。指令循环包括几个机器循环：指令提取、地址提取、操作数提取、执行和中断（见图V.7）。在每个机器循环期间计算机执行的主要操作在下文以`ADD`指令为例进行了说明。

Выборка команды. В данном машинном цикле выполняется чтение команды из памяти и ее частичное декодирование.  
指令提取。在这个机器循环中，从内存中读取指令并进行部分解码。

1. Исходное состояние памяти представлено на рис. В.8а. В ЭВМ загружена программа, выполняющая вычисление Z=-X+Y:  
   内存的初始状态如图V.8a所示。计算机中加载了一个计算Z=-X+Y的程序:  
   020 Значение X=-5316= ${FFAD}_{16}$   
   020 X值=-5316= ${FFAD}_{16}$

   021 Значение Y= ${106}_{16}$  
   021 Y值= ${106}_{16}$

   022 Место хранения для переменной Z (обнулено)  
   022 变量Z的存储位置（已清零）

   023 CLA - обнуление аккумулятора  
   023 CLA - 清零累加器

   024 SUB 20 - содержимое ячейки 20 вычитается из AC, в нем будет -X  
   024 SUB 20 - 将地址20的内容从AC中减去，结果为-X

   025 ADD 21 - Добавление ячейки 21 к AC. Т.е. AC сумма -20 + 21 ячеек.  
   025 ADD 21 - 将地址21的内容加到AC中。即AC的值为-20 + 21的内容。

   026 ST 22 - запись значения суммы в ячейку 22
   026 ST 22 - 将和的值存入地址22

   027 HLT - останов программы  
   027 HLT - 程序停止

   Счетчик команд (IP), как мы помним, всегда содержит адрес следующей исполняемой команды. Перед началом цикла выборки команды в IP содержится значение 025, значит в настоящий момент выполнение программы будет производиться с этого адреса.  
   指令计数器（IP），我们记得，总是包含下一条要执行的指令的地址。在指令提取循环开始之前，IP中包含值025，这意味着当前的程序执行将从该地址开始。

2. Цикл выборки команды начинается с выбора кода команды (рис. В.8б). По фронту (на этой и последующей картинках изображен красным, сплошным) импульса тактового генератора содержимое счетчика команд (11 разрядов, 5 старших разрядов будут установлены в 0) попадает на правый вход АЛУ. На левый вход АЛУ ничего не подается (т.е. все разряды установлены в значение 0). АЛУ сложит (операция по умолчанию в АЛУ, если не установлены другие вентили операций АЛУ) 0 с 25 и подаст на коммутатор. Коммутатор в данном такте пропустит данные неизмененными.  
指令提取循环从指令码的提取开始（图V.8b）。在时钟脉冲的上升沿（在本图和后续图中以红色实线表示）时，指令计数器的内容（11位，5位高位将被设置为0）被送到ALU的右输入端。ALU的左输入端没有输入（即所有位都设置为0）。ALU将（默认操作，如果没有设置其他ALU操作门）0与25相加，并将结果送到分配器。分配器在这个时钟周期将数据不变地通过。

По спаду (изображен зеленым, прерывистым) сигнала тактового генератора, выход коммутатора будет записан в 16-ти разрядный буферный регистр и, одновременно с этим, с выхода коммутатора 11 младших разрядов по шине передастся в 11-ти разрядный регистр адреса. Таким образом в AR появится адрес исполняемой в настоящий момент инструкции.  
在时钟脉冲的下降沿（以绿色虚线表示）时，分配器的输出将被写入16位缓冲寄存器，同时，分配器的11位低位通过总线传送到11位地址寄存器。因此，AR中出现当前执行指令的地址。

3. В следующем такте (рис. B.8в) По содержимому регистра (AR)  
   在下一个周期（图 B.8c）中，根据寄存器 (AR) 的内容
![](/OPD/Picture/1.9.B.8.png)
Рисунок B.8 Цикл выборки команды  
图 B.8 命令选择周期
![](/OPD/Picture/1.9.B.9.png)
Рисунок B.9 Цикл выборки операнда (а,б) и цикл исполнения (в)  
图 B.9 操作数获取周期（a,b）和执行周期（c）

содержимое 25 ячейки выбирается из памяти в регистр данных (DR). Т.к. при обращении к памяти левая часть схемы остается незадействованной, то возможны одновременные с обращением к памяти другие операции с АЛУ и регистрами. Соответственно содержимое BR подается на левый вход АЛУ, правый вход АЛУ при этом закрыт, и содержимое BR (равное IP) увеличивается на 1 в АЛУ, результат этой операции попадает в IP. Счетчик команд теперь содержит адрес следующей исполняемой команды.  
25号存储单元的内容从内存中选入数据寄存器（DR）。由于在访问内存时电路的左侧部分未被使用，因此可以同时进行与内存访问、ALU和寄存器相关的其他操作。BR的内容被送入ALU的左输入端，而ALU的右输入端被关闭，且BR的内容（等于IP）在ALU中增加1，操作结果进入IP。指令计数器现在包含下一条将要执行的指令的地址。

4. Для завершения цикла выборки команды (рис. В.8г) необходимо переслать код команды, на предыдущих шагах вычитанный из памяти в регистр команд. Для этого содержимое регистра данных через правый вход АЛУ по фронту передается в коммутатор, а по спаду выход коммутатора записывается в регистр команд (CR). Теперь CR содержит код исполняемой команды для его дальнейшего декодирования и определения типа исполняемой команды и режимов адресации.  
为完成指令提取循环（图V.8g），需要将前面步骤中从内存中读取到的指令码传输到指令寄存器。为此，数据寄存器的内容通过ALU的右输入端在时钟脉冲的上升沿传送到分配器，并在下降沿时分配器的输出被写入指令寄存器（CR）。现在CR包含了将要执行的指令的码，用于进一步解码和确定指令类型及寻址模式。

Цикл выборки адреса в данной команде с абсолютной адресацией отсутствует, т.к. полностью сформированный адрес непосредственно записан в коде команды. ЭВМ переходит к следующему циклу.  
对于具有绝对地址的指令，不需要地址提取循环，因为完全形成的地址已直接写入指令码。计算机转到下一个循环。

Цикл выборки операнда. Для команды `ADD 21` ЭВМ должна выбрать содержимое ячейки памяти с адресом 21 в DR, чтобы на следующем машинном цикле исполнения сложить содержимое регистра данных с аккумулятором. Напомним, что перед циклом выборки операнда код команды находится в регистре данных. По тактам происходит следующее:  
操作数提取循环。对于`ADD 21`指令，计算机必须从地址为21的内存单元中提取内容到DR中，以便在下一机器周期内将数据寄存器的内容与累加器的内容相加。我们记得，在操作数提取循环之前，指令码在数据寄存器中。时钟周期内发生以下操作：
   1. Содержимое DR подается в левый вход АЛУ (рис. В.9а). Младшие 11 разрядов выхода АЛУ и коммутатора подаются в регистр адреса. На левый вход АЛУ в это время подается 0.  
   DR的内容送入ALU的左输入端（图V.9a）。ALU和分配器输出的低11位送入地址寄存器。此时ALU的左输入端为0。
   
   2. По адресу 021 в AR из памяти загружается в DR (рис. В.9б).  
   Циклы выборки адреса и выборки операнда подробно описаны для каждого вида адресации на рис. В.10.  
   地址021的内容从内存中加载到DR中（图V.9b）。  
   地址提取循环和操作数提取循环的详细说明请见图V.10。
   ![](/OPD/Picture/1.9.B.10.png)

   Рисунок B.10 Цикл выборки адреса и операнда для различных режимов адресации  
   图 B.10 不同寻址模式下的地址和操作数取回周期  

Исполнение. Последовательность действий, выполняемых в этом машинном цикле, определяется самой выполняемой командой. Для подробного изучения цикла исполнения каждой микрокоманды необходимо обратиться к микрокоду БЭВМ (табл. В.21).  
执行。 在这个机器周期内执行的操作顺序由当前执行的指令决定。要详细了解每个微指令的执行周期，需要参考BЭBM的微代码（表B.21）。

Цикл исполнения для команды `ADD 21` умещается в один такт (рис. В.9в): Содержимое DR подается на левый вход АЛУ, а содержимое аккумулятора на правый вход АЛУ и производится операция сложения. Коммутатор передаст результат сложения на блок проверок неизменным.  
`ADD 21`指令的执行周期只需要一个时钟周期（图B.9v）：DR的内容传送到ALU的左输入端，累加器的内容传送到ALU的右输入端，然后进行加法操作。分配器将加法结果传送到检查单元，不做任何修改。

Далее выход коммутатора (результат сложения) записывается в AC, устанавливая при этом признаки выполнения операции. Т.к. при сложении переноса и переполнения не было, то в C и V запишется 0, в признак отрицательного числа (N) запишется 0, т.к. результат сложения получился положительным, и признак Z установится так же значение 0, т.к. результат не равен нулю.  
然后，分配器的输出（加法结果）写入AC，同时设置操作完成标志。由于加法过程中没有发生进位和溢出，因此C和V标志被置为0，负数标志(N)被置为0，因为加法结果是正数，Z标志也被置为0，因为结果不为零。

Команда выполнена, далее МПУ производит проверку на необходимость выполнить "ОСТАНОВ" и цикл прерывания, и управление передается на начало микрокода.  
指令执行完成，接下来MPU会检查是否需要执行“停止”指令和中断周期，然后控制权转移到微代码的起始位置。

Машинный цикл прерывания будет рассмотрен в разделе 2.4. приложения В.  
中断机器周期将在附录B的第2.4节中讨论。













































  










