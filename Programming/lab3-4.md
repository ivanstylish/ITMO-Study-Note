### 实验内容
Тут он поглубже засунул руку в левый карман и вытащил оттуда маленькое зеркальце, которым он обычно пускал солнечных зайчиков. Подойдя совсем близко к синьору Помидору, Чиполлино повертел зеркальцем перед самым его носом: Кавалер Помидор не удержался от искушения и одним глазом посмотрел в зеркальце. Неизвестно, что он надеялся там увидеть, но, конечно, увидел только свою собственную красную, как огонь, физиономию со злыми маленькими глазками и широким ртом, похожим на прорезь копилки.
他把手伸进左边的口袋里，掏出了一面他通常用来反射太阳光的小镜子。走近番茄骑士，洋葱头把镜子在他的鼻子前晃了晃。番茄骑士禁不住诱惑，用一只眼睛看向镜子。谁也不知道他希望看到什么，但显然他只看到了自己那张红得像火一样的脸，满是愤怒的小眼睛，还有像存钱罐投币口一样的大嘴。(这段情节通过洋葱头的挑衅行为，展示了番茄骑士的虚荣与脆弱。洋葱头巧妙地利用镜子反射番茄骑士的外貌，使他无奈地面对自己真实的形象。番茄骑士的愤怒与外貌形成强烈对比，突显出他的内在不安和虚弱。)



## Лабораторная работа #3-4
В соответствии с выданным вариантом на основе предложенного текстового отрывка из литературного произведения создать объектную модель реального или воображаемого мира, описываемого данным текстом. Должны быть выделены основные персонажи и предметы со свойственным им состоянием и поведением. На основе модели написать программу на языке Java.  
根据给定的变式，在提出的文学作品文本段落的基础上，创建该文本所描述的真实或 想象世界的对象模型。 应确定主要人物和物体及其特有的状态和行为。 在该模型的基础上，用 Java 编写一个程序。  
### Этапы выполнения работы:
1. Получить вариант
2. Нарисовать UML-диаграмму, представляющую классы и интерфейсы объектной модели и их взаимосвязи;绘制表示对象模型的类和接口及其关系的 UML 图；
3. Придумать сценарий, содержащий действия персонажей, аналогичные приведенным в исходном тексте;设计一个场景，其中包含与原文相似的人物动作；
4. Согласовать диаграмму классов и сценарий с преподавателем;与指导老师商定课堂图表和脚本；
5. Написать программу на языке Java, реализующую разработанные объектную модель и сценарий взаимодействия и изменения состояния объектов. При запуске программа должна проигрывать сценарий и выводить в стандартный вывод текст, отражающий изменение состояния объектов, приблизительно напоминающий исходный текст полученного отрывка.编写一个 Java 程序，实现所开发的对象模型以及对象状态的交互和变化场景。 程序启动时，应播放该场景并向标准输出端输出反映对象状态变化的文本，该文本应与接收到的段落源文本大致相同。
6. Продемонстрировать выполнение программы на сервере helios.在 helios 服务器上演示程序的执行。
7. Ответить на контрольные вопросы и выполнить дополнительное задание.回答测试问题并完成补充作业。
Текст, выводящийся в результате выполнения программы не обязан дословно повторять текст, полученный в исходном задании. Также не обязательно реализовывать грамматическое согласование форм и падежей слов выводимого текста.   
执行程序后输出的文本不必逐字重复原始任务中获得的文本。 输出文本的词形和词义也无需实现语法一致。 

Стоит отметить, что цель разработки объектной модели состоит не в выводе текста, а в эмуляции объектов предметной области, а именно их состояния (поля) и поведения (методы). Методы в разработанных классах должны изменять состояние объектов, а выводимый текст должен являться побочным эффектом, отражающим эти изменения.  
值得注意的是，开发对象模型的目的不是输出文本，而是模拟主题领域的对象，即它们的状态（字段）和行为（方法）。 开发的类中的方法应能改变对象的状态，而输出文本应是反映这些变化的副作用。  

### Требования к объектной модели, сценарию и программе:
1. В модели должны быть представлены основные персонажи и предметы, описанные в исходном тексте. Они должны иметь необходимые атрибуты и характеристики (состояние) и уметь выполнять свойственные им действия (поведение), а также должны образовывать корректную иерархию наследования классов.模型应代表源文本中描述的主要人物和物品。 它们必须具有必要的属性和特征（状态），能够执行其动作（行为），并且必须形成正确的类继承层次结构。
2. Объектная модель должна реализовывать основные принципе ООП - инкапсуляцию, наследование и полиморфизм. Модель должна соответствовать принципам SOLID, быть расширяемой без глобального изменения структуры модели.对象模型应贯彻 OOP 的基本原则--封装、继承和多态性。 模型必须符合 SOLID 原则，并可在不对模型结构进行全面更改的情况下进行扩展。 
3. Сценарий должен быть вариативным, то есть при изменении начальных характеристик персонажей, предметов или окружающей среды, их действия могут изменяться и отклоняться от базового сценария, приведенного в исходном тексте. Кроме того, сценарий должен поддерживать элементы случайности (при генерации персонажей, при задании исходного состояния, при выполнении методов).情景应该是可变的，也就是说，当人物、物体或环境的初始特征发生变化时，他们的行动也会发生变化，偏离源文本中给出的基本情景。 此外，情景应支持随机元素（在生成角色、设置初始状态和执行方法时）。
4. Объектная модель должна содержать как минимум один корректно использованный элемент каждого типа из списка:对象模型必须包含列表中每种类型的至少一个正确使用的元素：
    1. абстрактный класс как минимум с одним абстрактным методом;至少有一个抽象方法的抽象类；
    2. интерфейс;接口；
    3. перечисление (enum);枚举（枚举）；
    4.  запись (record);记录；
    5.  массив или ArrayList для хранения однотипных объектов;数组或 ArrayList 来存储相同类型的对象；
    6.  проверяемое исключение.已检查的例外情况。
5. В созданных классах основных персонажей и предметов должны быть корректно переопределены методы `equals()`, `hashCode()` и `toString()`. Для классов-исключений необходимо переопределить метод `getMessage()`.在创建的主字符和项目类中，必须正确重载 `equals()`、`hashCode()` 和 `toString()` 方法。 异常类必须重载 `getMessage()` 方法。
6. Созданные в программе классы-исключения должны быть использованы и обработаны. Кроме того, должно быть использовано и обработано хотя бы одно unchecked исключение (можно свое, можно из стандартной библиотеки).必须使用和处理在程序中创建的异常类。 此外，还必须使用和处理至少一个未选中的异常（可以是自己的异常，也可以来自标准库）。
7. При необходимости можно добавить внутренние, локальные и анонимные классы.您可以根据需要添加内部类、本地类和匿名类。

### Вопросы к защите лабораторной работы:
1. Принципы объектно-ориентированного программирования **SOLID** и **STUPID**.
    1. **SOLID** - это аббревиатура, представляющая собой пять основных принципов объектно-ориентированного программирования и проектирования.
       - `S` - SRP (Принцип единственной ответственности): Объект должен иметь только одну причину для изменения.
       - `O` - OCP (Принцип открытости/закрытости): Программные сущности должны быть открыты для расширения, но закрыты для модификации.
       - `L` - LSP (Принцип подстановки Барбары Лисков): Объекты в программе должны быть заменяемыми на экземпляры их подтипов без изменения правильности выполнения программы.
       - `I` - ISP (Принцип разделения интерфейса): Клиенты не должны зависеть от классов, которые они используют.
       - `D` - DIP (Принцип инверсии управления): Зависимости внутри системы строятся на основе абстракций, а не на основе конкретных реализаций.
   1. **STUPID** - это аббревиатура, которая в значительной степени употребляется в современном мире. Она обозначает пять принципов, которые не следует придерживаться при проектировании и реализации программного обеспечения.
2. Класс `Object`. Реализация его методов по умолчанию.
   Object – базовый класс для всех классов. его методы. `toString()`Метод `toString` служит для получения представления данного объекта в виде строки., `equals()`Метод `equals` сравнивает два объекта на равенство:, `hashCode()`Метод `hashCode` позволяет задать некоторое числовое значение, которое будет соответствовать данному объекту или его хэш-код..
3. Простое и множественное наследование. Особенности реализации наследования в Java.
   множественное наследование не поддерживается между **классами**, но оно поддерживается между **интерфейсами**
4. Понятие абстрактного класса. Модификатор `abstract`.
   базовый класс, который не предполагает создания экземпляров.Абстрактный класс может содержать (и не содержать) абстрактные методы и свойства. Модификатор `abstract` используется для объявления класса как абстрактного.
5. Понятие интерфейса. Реализация интерфейсов в Java. Отличие интерфейсов от абстрактных классов.
6. Модификаторы `default`, `static` и `private` для методов интерфейса.
7. Перечисляемый тип данных (enum) в Java. Особенности реализации и использования.
8. Тип запись (record) в Java. Особенности использования.
9.  Методы и поля с модификаторами `static` и `final`.
10.  Перегрузка и переопределение методов.
11. Обработка исключительных ситуаций, три типа исключений.
12. Стандартный массив и динамический массив (ArrayList). Основные различия.
13. Вложенные, локальные и анонимные классы.
 