### 实验内容
Тут он поглубже засунул руку в левый карман и вытащил оттуда маленькое зеркальце, которым он обычно пускал солнечных зайчиков. Подойдя совсем близко к синьору Помидору, Чиполлино повертел зеркальцем перед самым его носом: Кавалер Помидор не удержался от искушения и одним глазом посмотрел в зеркальце. Неизвестно, что он надеялся там увидеть, но, конечно, увидел только свою собственную красную, как огонь, физиономию со злыми маленькими глазками и широким ртом, похожим на прорезь копилки.
他把手伸进左边的口袋里，掏出了一面他通常用来反射太阳光的小镜子。走近番茄骑士，洋葱头把镜子在他的鼻子前晃了晃。番茄骑士禁不住诱惑，用一只眼睛看向镜子。谁也不知道他希望看到什么，但显然他只看到了自己那张红得像火一样的脸，满是愤怒的小眼睛，还有像存钱罐投币口一样的大嘴。(这段情节通过洋葱头的挑衅行为，展示了番茄骑士的虚荣与脆弱。洋葱头巧妙地利用镜子反射番茄骑士的外貌，使他无奈地面对自己真实的形象。番茄骑士的愤怒与外貌形成强烈对比，突显出他的内在不安和虚弱。)



## Лабораторная работа #3-4
В соответствии с выданным вариантом на основе предложенного текстового отрывка из литературного произведения создать объектную модель реального или воображаемого мира, описываемого данным текстом. Должны быть выделены основные персонажи и предметы со свойственным им состоянием и поведением. На основе модели написать программу на языке Java.  
根据给定的变式，在提出的文学作品文本段落的基础上，创建该文本所描述的真实或 想象世界的对象模型。 应确定主要人物和物体及其特有的状态和行为。 在该模型的基础上，用 Java 编写一个程序。  
### Этапы выполнения работы:
1. Получить вариант
2. Нарисовать UML-диаграмму, представляющую классы и интерфейсы объектной модели и их взаимосвязи;绘制表示对象模型的类和接口及其关系的 UML 图；
3. Придумать сценарий, содержащий действия персонажей, аналогичные приведенным в исходном тексте;设计一个场景，其中包含与原文相似的人物动作；
4. Согласовать диаграмму классов и сценарий с преподавателем;与指导老师商定课堂图表和脚本；
5. Написать программу на языке Java, реализующую разработанные объектную модель и сценарий взаимодействия и изменения состояния объектов. При запуске программа должна проигрывать сценарий и выводить в стандартный вывод текст, отражающий изменение состояния объектов, приблизительно напоминающий исходный текст полученного отрывка.编写一个 Java 程序，实现所开发的对象模型以及对象状态的交互和变化场景。 程序启动时，应播放该场景并向标准输出端输出反映对象状态变化的文本，该文本应与接收到的段落源文本大致相同。
6. Продемонстрировать выполнение программы на сервере helios.在 helios 服务器上演示程序的执行。
7. Ответить на контрольные вопросы и выполнить дополнительное задание.回答测试问题并完成补充作业。
Текст, выводящийся в результате выполнения программы не обязан дословно повторять текст, полученный в исходном задании. Также не обязательно реализовывать грамматическое согласование форм и падежей слов выводимого текста.   
执行程序后输出的文本不必逐字重复原始任务中获得的文本。 输出文本的词形和词义也无需实现语法一致。 

Стоит отметить, что цель разработки объектной модели состоит не в выводе текста, а в эмуляции объектов предметной области, а именно их состояния (поля) и поведения (методы). Методы в разработанных классах должны изменять состояние объектов, а выводимый текст должен являться побочным эффектом, отражающим эти изменения.  
值得注意的是，开发对象模型的目的不是输出文本，而是模拟主题领域的对象，即它们的状态（字段）和行为（方法）。 开发的类中的方法应能改变对象的状态，而输出文本应是反映这些变化的副作用。  

### Требования к объектной модели, сценарию и программе:
1. В модели должны быть представлены основные персонажи и предметы, описанные в исходном тексте. Они должны иметь необходимые атрибуты и характеристики (состояние) и уметь выполнять свойственные им действия (поведение), а также должны образовывать корректную иерархию наследования классов.模型应代表源文本中描述的主要人物和物品。 它们必须具有必要的属性和特征（状态），能够执行其动作（行为），并且必须形成正确的类继承层次结构。
2. Объектная модель должна реализовывать основные принципе ООП - инкапсуляцию, наследование и полиморфизм. Модель должна соответствовать принципам SOLID, быть расширяемой без глобального изменения структуры модели.对象模型应贯彻 OOP 的基本原则--封装、继承和多态性。 模型必须符合 SOLID 原则，并可在不对模型结构进行全面更改的情况下进行扩展。 
3. Сценарий должен быть вариативным, то есть при изменении начальных характеристик персонажей, предметов или окружающей среды, их действия могут изменяться и отклоняться от базового сценария, приведенного в исходном тексте. Кроме того, сценарий должен поддерживать элементы случайности (при генерации персонажей, при задании исходного состояния, при выполнении методов).情景应该是可变的，也就是说，当人物、物体或环境的初始特征发生变化时，他们的行动也会发生变化，偏离源文本中给出的基本情景。 此外，情景应支持随机元素（在生成角色、设置初始状态和执行方法时）。
4. Объектная модель должна содержать как минимум один корректно использованный элемент каждого типа из списка:对象模型必须包含列表中每种类型的至少一个正确使用的元素：
    1. абстрактный класс как минимум с одним абстрактным методом;至少有一个抽象方法的抽象类；
    2. интерфейс;接口；
    3. перечисление (enum);枚举（枚举）；
    4.  запись (record);记录；
    5.  массив или ArrayList для хранения однотипных объектов;数组或 ArrayList 来存储相同类型的对象；
    6.  проверяемое исключение.已检查的例外情况。
5. В созданных классах основных персонажей и предметов должны быть корректно переопределены методы `equals()`, `hashCode()` и `toString()`. Для классов-исключений необходимо переопределить метод `getMessage()`.在创建的主字符和项目类中，必须正确重载 `equals()`、`hashCode()` 和 `toString()` 方法。 异常类必须重载 `getMessage()` 方法。
6. Созданные в программе классы-исключения должны быть использованы и обработаны. Кроме того, должно быть использовано и обработано хотя бы одно unchecked исключение (можно свое, можно из стандартной библиотеки).必须使用和处理在程序中创建的异常类。 此外，还必须使用和处理至少一个未选中的异常（可以是自己的异常，也可以来自标准库）。
7. При необходимости можно добавить внутренние, локальные и анонимные классы.您可以根据需要添加内部类、本地类和匿名类。

### Вопросы к защите лабораторной работы:
1. Принципы объектно-ориентированного программирования **SOLID** и **STUPID**.
    1. **SOLID** - это аббревиатура, представляющая собой пять основных принципов объектно-ориентированного программирования и проектирования.
       - `S` - SRP (Принцип единственной ответственности): Объект должен иметь только одну причину для изменения.
       - SRP（单一责任原则）： 一个对象只有一个更改原因。 
       - `O` - OCP (Принцип открытости/закрытости): Программные сущности должны быть открыты для расширения, но закрыты для модификации.
       - OCP（开放/封闭原则）： 软件实体应开放扩展，但禁止修改。
       - `L` - LSP (Принцип подстановки Барбары Лисков): Объекты в программе должны быть заменяемыми на экземпляры их подтипов без изменения правильности выполнения программы.
       - LSP（芭芭拉-利斯科夫置换原理）： 程序中的对象应可由其子类型的实例替换，而不会改变程序执行的正确性。
       - `I` - ISP (Принцип разделения интерфейса): Клиенты не должны зависеть от классов, которые они используют.
       - ISP（界面分离原则）： 客户端不应依赖于它们使用的类。
       - `D` - DIP (Принцип инверсии управления): Зависимости внутри системы строятся на основе абстракций, а не на основе конкретных реализаций.
       - DIP（控制反转原理）： 系统内的依赖关系是建立在抽象而非具体实现的基础上的。
   2. **STUPID** - это аббревиатура, которая в значительной степени употребляется в современном мире. Она обозначает шесть принципов, которые не следует придерживаться при проектировании и реализации программного обеспечения.
       - одноэлементный
       - 单元素
       - Плотное соединение
       - 紧密连接
       - Непроверяемость
       - 不可核查性
       - Преждевременная оптимизация
       - 过早优化
       - Неназываемое именование
       - 无名命名
       - Дублирование
       - 复制
  
2. Класс `Object`. Реализация его методов по умолчанию.
   Object – базовый класс для всех классов. его методы. `toString()`Метод `toString` служит для получения представления данного объекта в виде строки., `equals()`Метод `equals` сравнивает два объекта на равенство:, `hashCode()`Метод `hashCode` позволяет задать некоторое числовое значение, которое будет соответствовать данному объекту или его хэш-код..
3. Простое и множественное наследование. Особенности реализации наследования в Java.
   множественное наследование не поддерживается между **классами**, но оно поддерживается между **интерфейсами**
4. Понятие абстрактного класса. Модификатор `abstract`.
   базовый класс, который не предполагает создания экземпляров.Абстрактный класс может содержать (и не содержать) абстрактные методы и свойства. Модификатор `abstract` используется для объявления класса как абстрактного.
5. Понятие интерфейса. Реализация интерфейсов в Java. Отличие интерфейсов от абстрактных классов.
   это ключевой элемент , который предоставляет абстракцию для определения контракта между объектами.Интерфейсы определяются с помощью ключевого слова `interface`.Нужно добавлять ключевое слово `implements` после имени класса, в котором вы хотите реализовать этот интерфейс. 1. основное различие между интерфейсом и абстрактным классом заключается в том, что интерфейс не может иметь состояния, тогда как абстрактный класс может (в виде полей экземпляра). 2. классы могут реализовывать более одного интерфейса, но расширять только один абстрактный класс.  
   接口是一个关键元素，它提供了一个抽象概念来定义对象之间的契约。接口是使用 "interface "关键字定义的。 接口和抽象类的主要区别在于接口不能有状态，而抽象类可以有状态（以实例字段的形式）。 2. 类可以实现多个接口，但只能扩展一个抽象类。
6. Модификаторы `default`, `static` и `private` для методов интерфейса.
`default`:Методы с реализацией по умолчанию,в интерфейсах можно определять методы с реализацией по умолчанию и такие методы можно не переопределять в классах. `static`:Статические методы интерфейса аналогичны статическим методам в классах: они принадлежат интерфейсу и вызываются через имя интерфейса. `private` методы помогают структурировать код внутри интерфейса, предотвращая дублирование.  
`default`:缺省实现的方法，缺省方法可以在接口中定义，此类方法不能在类中重载。 `static`:接口中的静态方法与类中的静态方法类似：它们属于接口，通过接口名称调用。 `private` 方法有助于结构化接口中的代码，防止重复。  
7. Перечисляемый тип данных (enum) в Java. Особенности реализации и использования.
   Перечисления могут иметь собственные методы, поля и конструкторы.Перечисляемые типы объявляются с помощью ключевого слова `enum`  
   枚举类型可以有自己的方法、字段和构造函数。  
8. Тип запись (record) в Java. Особенности использования.
Тип записи определяется с помощью ключевого слова `record`.`record` представляет классы, которые предназначены для создания контейнеров неизменяемых данных.
9.  Методы и поля с модификаторами `static` и `final`.
    1. Ключевое слово `final` можно использовать для переменных, методов и классов.
       - `final` переменную нельзя переназначить на другой объект.
       - у него не может быть наследников
       - `final` метод не может быть переопределен у предка.
    2. При обозначении переменной уровня класса мы указываем на то, что это значение относится к классу. Если этого не делать, то значение переменной будет привязываться к объекту, созданному по этому классу. А то, что если переменная не статическая, то у каждого нового объекта данного класса будет своё значение этой переменной, меняя которое мы меняем его исключительно в одном объекте:Статические методы позволяют получить доступ только к статическим членам.  
在给类级变量贴标签时，我们要指明变量值指向的是类。 如果不这样做，变量值就会绑定到该类创建的对象上。 而事实上，如果变量不是静态的，那么该类的每个新对象都将拥有自己的变量值，我们只能在一个对象中改变它：静态方法只允许访问静态成员。  
10. Перегрузка и переопределение методов.
    Использование более одного метода с одним и тем же именем, но с разными параметрами в одном и том же классе или методе между суперклассом и подклассом в Java называется перегрузкой (`Overload`)
    В Java мы можем создать суперкласс и подклассы, которые наследуются от этого класса. Эти подклассы могут переопределять и заменять методы родительского класса, которые они наследуют. Это делается с помощью метода переопределения (`Override`).(当同一个类中的方法具有相同的方法名但不同的参数时，就会发生重载；而当两个方法具有相同的方法名和参数时，就会发生覆盖。)
11. Обработка исключительных ситуаций, три типа исключений.
`try` — блок, где может возникнуть исключение  
可能出现异常的块  
`catch` — блок, который перехватывает исключение и обрабатывает его.  
块拦截异常并进行处理。  
`finally` — блок, который выполняется всегда, независимо от того, было ли исключение или нет. Часто используется для освобождения ресурсов, например, закрытия файлов.  
块，无论是否出现异常，它都会被执行。 通常用于释放资源，如关闭文件。  
    1.  `Проверяемые исключения (Checked Exceptions)`
Проверяемые исключения — это исключения, которые должны быть обработаны или явно указаны в сигнатуре метода с использованием ключевого слова `throws`. Эти исключения могут возникнуть в процессе нормальной работы программы и требуют специального внимания разработчика.
已检查异常 已检查异常是必须处理的异常，或在方法签名中使用 throws 关键字明确指定的异常。 这些异常可能会在程序正常运行时发生，需要开发人员特别注意。
    2. `Непроверяемые исключения (Unchecked Exceptions)`
Непроверяемые исключения — это исключения, которые происходят из-за ошибок программиста, например, при неправильных расчетах или работе с некорректными данными. Эти исключения наследуются от класса `RuntimeException`. Разработчик не обязан обрабатывать их, и они могут быть выброшены во время выполнения программы.
未检查异常 未检查异常是由于程序员错误（如计算错误或数据错误）而导致的异常。 这些异常继承自 RuntimeException 类。 开发人员没有义务处理它们，它们可以在运行时抛出。
    3. `Ошибки (Errors)`
Ошибки — это исключительные ситуации, которые обычно не поддаются обработке в программе. Они происходят на уровне виртуальной машины или системы и представляют собой серьезные проблемы, которые не могут быть устранены с помощью обычных механизмов обработки исключений. Эти ошибки наследуются от класса `Error`.
错误 错误是程序中无法正常处理的异常情况。 它们发生在虚拟机或系统级别，代表正常异常处理机制无法处理的严重问题。 这些错误继承自 Error 类。
12. Стандартный массив и динамический массив (ArrayList). Основные различия. 
Разница между стандартным массивом и массивом ArrayList в Java заключается в том, что в первом случае размер массива нельзя изменить (если вы хотите добавить или удалить элементы в/из массива, вам нужно создать новый). Тогда как в ArrayList элементы могут быть добавлены и удалены когда угодно.  
普通数组是具有固定长度的线性元素集合，可以存储数据，通常是同一类型的数据。 它的长度是动态变化的，因此被称为动态数组。 在 Java 中，标准数组与 ArrayList 数组的区别在于，前者的数组大小不能改变（如果要在数组中添加或删除元素，则需要创建一个新数组）。 而在 ArrayList 中，可以随时添加和删除元素。  
13. Вложенные, локальные и анонимные классы. 嵌套类、局部类和匿名类
**Вложенные классы嵌套类** можно прописывать внутри других классов. Такое зачастую используется, когда вложенный класс дополняет основной класс и является его частью.  
可以写入其他类中。 当嵌套类补充主类并成为主类的一部分时，通常会使用这种方法。   
**Локальные классы局部类** — это классы, определённые внутри метода. Они могут быть использованы только в области видимости этого метода. Локальные классы не могут обращаться к локальным переменным метода, если только эти переменные не объявлены как final или константы.  
**局部类**是在方法内部定义的类。 它们只能在该方法的范围内使用。 局部类不能访问方法的局部变量，除非这些变量被声明为 final 或常量。   
**Анонимные классы匿名类** - это классы, что не имеют имени и их создание происходит в момент инициализации объекта.    
是没有名称的类，在对象初始化时创建。

 