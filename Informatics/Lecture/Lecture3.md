## [主页](../README.md)/Lecture3
## Лекция №3. Тема: «Современные языки программирования. Python. Основы регулярных выражений.»
## 第 3 次讲座。 主题："现代编程语言。 Python. 正则表达式基础。"

Регулярные выражения (regular expressions) — последовательность символов, определяющая шаблон для поиска в строках.
正则表达式 - 定义在字符串中搜索模式的字符序列。

正则表达式是一个特殊的字符序列，它能帮助你方便的检查一个字符串是否与某种模式匹配。
`re` 模块使 `Python` 语言拥有全部的正则表达式功能。
`compile` 函数根据一个模式字符串和可选的标志参数生成一个**正则表达式对象**。该对象拥有一系列方法用于正则表达式匹配和替换。

### re.match函数
`re.match` 尝试从字符串的起始位置匹配一个模式，如果不是起始位置匹配成功的话，`match()` 就返回 `none`。
```
re.match(pattern, string, flags=0)
```
|参数|描述|
|:----:|:----:|
|pattern|匹配的正则表达式|
|string|要匹配的字符串|
|flags|标志位，用于控制正则表达式的匹配方式，如：是否区分大小写，多行匹配等等|

我们可以使用 `group(num)` 或 `groups()` 匹配对象函数来获取匹配表达式。
|匹配对象方法|描述|
|:----:|:----:|
|group(num=0)|匹配的整个表达式的字符串，group() 可以一次输入多个组号，在这种情况下它将返回一个包含那些组所对应值的元组。|
|groups()|返回一个包含所有小组字符串的元组，从 1 到 所含的小组号。|

### re.search函数
`re.search` 扫描整个字符串并返回第一个成功的匹配。
```
re.search(pattern, string, flags=0)
```
同上match函数

### re.match与re.search的区别
`re.match`只匹配字符串的开始，如果字符串开始不符合正则表达式，则匹配失败，函数返回`None`；而`re.search`匹配整个字符串，直到找到一个匹配。

### 检索和替换
re.sub用于替换字符串中的匹配项。
```
re.sub(pattern, repl, string, count=0, flags=0)
```
|参数|描述|
|:----:|:----:|
|pattern|匹配的正则表达式|
|repl|替换的字符串，也可为一个函数|
|string|要被替换的字符串|
|count|最多替换的次数，默认 0 表示替换所有匹配的子串。|
|flags|标志位，用于控制正则表达式的匹配方式，如：是否区分大小写，多行匹配等等|

### 实例
```python
import re

# 匹配字符串开头的数字
pattern = r'\d+'
string = 'abc123def456'
match = re.match(pattern, string)
if match:
    print(match.group())  # 输出：123

# 匹配字符串中的数字
pattern = r'\d+'
string = 'abc123def456'
matches = re.findall(pattern, string)
print(matches)  # 输出：['123', '456']

# 匹配字符串中的数字，并替换为星号
pattern = r'\d+'
string = 'abc123def456'
new_string = re.sub(pattern, '*', string)
print(new_string)  # 输出：abc***def***

# 匹配字符串中的数字，并替换为星号，只替换一次
pattern = r'\d+'
string = 'abc123def456'
new_string = re.sub(pattern, '*', string, count=1)
print(new_string)  # 输出：abc***def456
```

### re.compile 函数
`compile` 函数用于编译正则表达式，生成一个正则表达式（ `Pattern `）对象，供 `match()` 和 `search()` 这两个函数使用。
```
re.compile(pattern, flags=0)
```
|参数|描述|
|:----:|:----:|
|pattern|匹配的正则表达式|
|flags|可选，表示匹配模式，比如忽略大小写，多行模式等，具体参数为：|
1. `re.l` 忽略大小写
2. `re.L` 表示特殊字符集 \w, \W, \b, \B, \s, \S 依赖于当前环境
3. `re.M` 多行模式
4. `re.S` 即为 . 并且包括换行符在内的任意字符（. 不包括换行符）
5. `re.U` 表示特殊字符集 \w, \W, \b, \B, \d, \D, \s, \S 依赖于 Unicode 字符属性数据库
6. `re.X` 为了增加可读性，忽略空格和 # 后面的注释

### findall 函数
在字符串中找到正则表达式所匹配的所有子串，并返回一个列表，如果有多个匹配模式，则返回元组列表，如果没有找到匹配的，则返回空列表。

**注意**： `match` 和 `search` 是匹配一次 `findall` 匹配所有。
```
re.findall(string[, pos[, endpos]])
```
|参数|描述|
|:----:|:----:|
|pattern|匹配的正则表达式|
|pos|可选，指定字符串的起始位置，默认为 0|
|endpos|可选，指定字符串的结束位置，默认为字符串的长度|

### re.finditer 函数
和 `findall` 类似，在字符串中找到正则表达式所匹配的所有子串，并把它们作为一个迭代器返回。

### re.split 函数
```
re.split(pattern, string, maxsplit=0, flags=0)
```
|参数|描述|
|:----:|:----:|
|pattern|匹配的正则表达式|
|string|要被分割的字符串|
|maxsplit|可选，分割次数，默认为 0 表示分割所有匹配的子串|
|flags|标志位，用于控制正则表达式的匹配方式，如：是否区分大小写，多行匹配等等|

### re.sub 函数
```
re.sub(pattern, repl, string, count=0, flags=0)
```
|参数|描述|
|:----:|:----:|
|pattern|匹配的正则表达式|
|repl|替换的字符串，也可为一个函数|
|string|要被替换的字符串|
|count|最多替换的次数，默认 0 表示替换所有匹配的子串。|
|flags|标志位，用于控制正则表达式的匹配方式，如：是否区分大小写，多行匹配等等|

### 正则表达式对象
#### re.RegexObject
re.compile() 返回 RegexObject 对象。

#### re.MatchObject
group() 返回被 RE 匹配的字符串。
1. start() 返回匹配开始的位置。
2. end() 返回匹配结束的位置。
3. span() 返回一个元组包含匹配 (start, end) 的位置。

### 正则表达式模式
|模式|描述|
|:----:|:----:|
|^|匹配字符串的开头|
|$|匹配字符串的末尾|
|.|匹配任意字符，除了换行符，当re.DOTALL标记被指定时，则可以匹配包括换行符的任意字符。|
|[...]|用来表示一组字符，单独列出：[amk] 匹配 'a'，'m'或'k'|
|[^...]|不在[]中的字符：[^abc] 匹配除了a,b,c之外的字符。|
|re*|匹配0个或多个的表达式。|
|re+|匹配1个或多个的表达式。|
|re?|匹配0个或1个由前面的正则表达式定义的片段，非贪婪方式|
|re{ n}|精确匹配 n 个前面表达式。例如， o{2} 不能匹配 "Bob" 中的 "o"，但是能匹配 "food" 中的两个 o。|
|re{ n,}|匹配 n 个前面表达式。例如， o{2,} 不能匹配"Bob"中的"o"，但能匹配 "foooood"中的所有 o。"o{1,}" 等价于 "o+"。"o{0,}" 则等价于 "o*"。|
|re{ n, m}|匹配 n 到 m 次由前面的正则表达式定义的片段|
|a| b|匹配a或b|
|(re)|对正则表达式分组并记住匹配的文本|
|(?imx)|正则表达式包含三种可选标志：i, m, 或 x 。只影响括号中的区域。|
|(?-imx)|正则表达式关闭 i, m, 或 x 可选标志。只影响括号中的区域。|
|(?: re)|类似 (...), 但是不表示一个组|
|(?imx: re)|在括号中使用i, m, 或 x 可选标志|
|(?-imx: re)|在括号中不使用i, m, 或 x 可选标志|
|(?#...)|注释.|
|(?= re)|前向肯定界定符。如果所含正则表达式，以 ... 表示，在当前位置成功匹配时成功，否则失败。但一旦所含表达式已经尝试，匹配引擎根本没有提高；模式的剩余部分还要尝试界定符的右边。|
|(?! re)|前向否定界定符。与肯定界定符相反；当所含表达式不能在字符串当前位置匹配时成功|
|(?> re)|匹配的独立模式，省去回溯。|
|\w|匹配字母数字及下划线|
|\W|匹配非字母数字及下划线|
|\s|匹配任意非空字符|
|\d|匹配任意数字，等价于 [0-9].|
|\D|匹配任意非数字|
|\A|匹配字符串开始|
|\Z|匹配字符串结束，如果是存在换行，只匹配到换行前的结束字符串。|
|\z|匹配字符串结束|
|\G|匹配最后匹配完成的位置。|
|\b|匹配一个单词边界，也就是指单词和空格间的位置。例如， 'er\b' 可以匹配"never" 中的 'er'，但不能匹配 "verb" 中的 'er'。|
|\B|匹配非单词边界。'er\B' 能匹配 "verb" 中的 'er'，但不能匹配 "never" 中的 'er'。|
|\n, \t, 等.|匹配一个换行符。匹配一个制表符。等|
|\1...\9|匹配第n个分组的内容。|
|\10|匹配第n个分组的内容，如果它经匹配。否则指的是八进制字符码的表达式。|

### 正则表达式实例
#### 字符类
|实例|描述|
|:----:|:----:|
|[Pp]ython|匹配 "Python" 或 "python"|
|rub[ye]|匹配 "ruby" 或 "rube"|
|[aeiou]|匹配中括号内的任意一个字母|
|[0-9]|匹配任何数字。类似于 [0123456789]|
|[a-z]|匹配任何小写字母|
|[A-Z]|匹配任何大写字母|
|[a-zA-Z0-9]|匹配任何字母及数字|
|[^aeiou]|除了aeiou字母以外的所有字符|
|[^0-9]|匹配除了数字外的字符|

分钟: ([0-5]?\d|\*)  
[0-5]?\d：匹配从 00 到 59 的分钟数，其中 \d 匹配任意一位数字，[0-5]? 表示分钟的十位只能是 0 到 5（或无十位，即单个数字的情况）。  
|*：允许使用 *，表示“任意分钟”。  
小时: ([01]?\d|2[0-3]|\*)  
[01]?\d：匹配从 00 到 19 的小时，其中 \d 匹配个位数字，[01]? 表示小时的十位只能是 0 或 1。  
2[0-3]：匹配 20 到 23 的小时。  
|*：允许使用 *，表示“任意小时”。  
天（日期）: ([1-9]|[12]\d|3[01]|\*)  
[1-9]：匹配从 1 到 9 的日期（单个数字）。  
[12]\d：匹配从 10 到 29 的日期，其中 [12] 表示十位可以是 1 或 2，\d 表示个位。  
3[01]：匹配 30 和 31。  
|*：允许使用 *，表示“任意日期”。  
月份: ([1-9]|1[0-2]|jan|feb|mar|apr|may|jun|jul|aug|sep|oct|nov|dec|\*)
[1-9]：匹配从 1 到 9 的月份。  
1[0-2]：匹配 10、11 和 12。  
|：允许使用英文月份缩写，例如 jan（1月）、feb（2月）等，以便支持月份名称。  
|*：允许使用 *，表示“任意月份”。  
星期几: ([0-6]|sun|mon|tue|wed|thu|fri|sat|\*)  
[0-6]：匹配从 0 到 6 的星期几，0 表示周日。  
|：允许使用英文星期缩写，例如 sun（周日）、mon（周一）等。  
|*：允许使用 *，表示“任意星期几”。  