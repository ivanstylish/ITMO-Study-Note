1. Протокол HTTP. Структура запросов и ответов, методы запросов, коды ответов сервера, заголовки запросов и ответов.
HTTP 协议。请求和响应的结构、请求方法、服务器响应代码、请求和响应标头。  
HTTP (англ. HyperText Transfer Protocol — «протокол передачи гипертекста») — протокол прикладного уровня передачи данных (изначально — в виде гипертекстовых документов в формате «HTML», в настоящий момент используется для передачи произвольных данных). Основой HTTP является технология «клиент-сервер»
HTTP（超文本传输​​协议）是一种应用层数据传输协议（最初以 HTML 格式的超文本文档形式出现，目前用于传输任意数据）。HTTP 基于客户端-服务器技术：  

Потребителей (клиентов), которые инициируют соединение и посылают запрос;  
Поставщиков (серверов), которые ожидают соединения для получения запроса, производят необходимые действия и возвращают обратно сообщение с результатом.  
HTTP запрос состоит из трех основных частей, которые идут в нем именно в том порядке, который указан ниже. Между заголовками и телом сообщения находится пустая строка (в качестве разделителя), она представляет собой символ перевода строки.  
消费者（客户端）发起连接并发送请求；  
提供者（服务器）等待连接接收请求，执行必要的操作并返回包含结果的消息。  
HTTP 请求由三个主要部分组成，按以下指定的顺序排列。在消息头和正文之间有一个空行（作为分隔符），它是一个换行符。  

строка запроса (Request Line)  
заголовки (Message Headers)  
пустая строка (разделитель)  
тело сообщения (Entity Body) – необязательный параметр
Строка запроса – указывает метод передачи, URL-адрес, к которому нужно обратиться и версию протокола HTTP. 
Заголовки – описывают тело сообщений, передают различные параметры и др. сведения и информацию. 
Тело сообщения — это сами данные, которые передаются в запросе. Тело сообщения – это необязательный параметр и может отсутствовать.  
请求行  
消息头  
空行（分隔符）  .
实体主体 - 可选  
请求行 - 指定传输方式、访问的 URL 以及 HTTP 协议版本。消息头 - 描述消息主体、传输各种参数以及其他信息。消息主体是请求中传输的数据本身。消息主体是可选参数，可以省略。  

Методы запросов:
GET запрашивает представление ресурса, может только извлекать данные.
HEAD как GET, только без тела ответа.
POST используется для отправк сущностей определенному ресурсу. Может изменять данные.
PUT создает новый ресурс или заменят предсавление целевого ресурса (в отличае от POST для идентичных наборов двнных будет иметь одинаковый результат).
DELETE удаляет ресурм.
CONNECT устанавливает "туннель" к серверу, определенному по ресурсу.
OPTIONS для описания параметров соединения с ресурсом
TRACE вызов возвращаемого текстового сообщения
PATCH частичное изменение ресурса
Коды ответов:
1хх: Informational
2xx: Success
3xx: Redirection (перенаправление)
4xx: Client Error
5xx: Server Error
请求方法：
GET 请求资源的表述，仅可检索数据。
HEAD 类似于 GET，但没有响应主体。
POST 用于将实体发送到特定资源。可以修改数据。
PUT 创建新资源或替换目标资源的表述（与 POST 不同，相同的数据集将产生相同的结果）。
DELETE 删除资源。
CONNECT 建立与资源指定服务器的“隧道”。
OPTIONS 用于描述与资源的连接参数。
TRACE 调用用于返回文本消息。
PATCH 对资源进行部分修改。
响应代码：
1xx：信息
2xx：成功
3xx：重定向
4xx：客户端错误
5xx：服务器错误

2. Язык разметки HTML. Особенности, основные теги и атрибуты тегов.
Документ состоит из элементов, начало и конец которых обозначаются тегами. Некоторые теги не могут содержать текст (например, <br> — перенос строки, <img> — картинка, <input> — элемент ввода в форме). Их не нужно закрывать:
HTML 标记语言。功能、基本标记和标记属性。  
```html
<!-- плохо -->
<input type="..."></input>
<!-- хорошо -->
<input type="...">
```
это стандартизированный язык разметки, который используется для создания и структурирования содержимого веб-страниц.  
是一种标准化的标记语言，用于创建和构建网页内容   

HTML использует набор тегов , заключенных в угловые скобки (< и >), чтобы выделить и описать различные части контента.   
HTML 使用一组用尖括号（< 和 >）括起来的标签来突出显示和描述不同的内容。  


В HTML5 введены семантические теги <header>, <footer>, <section>, которые аналогичны <div>, но указывают на логическую структуру.  
HTML5 引入了语义标签<header>、<footer>、<section>，它们与<div>类似，但表示逻辑结构。

3. Структура HTML-страницы. Объектная модель документа (DOM).
HTML 页面的结构。文档对象模型 （DOM）。  

DOM - программный интерфейс для HTML и XML документов, который представляет собой структурированное представление документа и определяет, как это структура может быть доступна из программ, которые могут изменять ее содержимое. (Другими словами, DOM соединяет веб-страницу с языками описания сценариев).  
DOM 是 HTML 和 XML 文档的编程接口，它描述了文档的结构化表示，并指定了程序如何访问该结构来修改其内容。（换句话说，DOM 将网页与脚本语言连接起来。）  

Согласно DOM документ может быть представлен в виде объектов, с которыми можно проихводить манипуляци:  
根据 DOM，文档可以表示为可操作的对象：  

генерация и добавление узлов
получение узлов
изменение узлов
изменение связей между ними
удаление узлов
Обращение к узлам происходит с помощью элементов document или window.  
生成和添加节点
获取节点
更改节点
更改节点之间的链接
删除节点
使用文档或窗口元素访问节点。

Есть еще BOM - объектная модель браузера. Основное предназначение — управление окнами браузера и обеспечение их взаимодействия. BOM специфична для каждого браузера. Может в создание системных диалогов, управление информацией о параметрах монитора и браузера и всякое такое.  
还有 BOM - 浏览器对象模型。其主要目的是管理浏览器窗口并确保它们之间的交互。BOM 是每个浏览器特有的。它可用于创建系统对话框、管理显示器和浏览器参数信息等等。  

4. HTML-формы. Задание метода HTTP-запроса. Правила размещения форм на страницах, виды полей ввода.
HTML 表单。设置 HTTP 请求方法。在页面上放置表单的规则，输入字段的类型。

Форма предназначена для обмена данными между пользователем и сервером.  
该表单用于用户和服务器之间的数据交换。  
  
Задается с помощью тега <form> и могут содержать в себе атрибуты: action, содержищий URI обработчика формы (обязательный атрибут), method (по умолчанию, GET), enctype (тип кодирования), accept (MIME-типы для загрузки файлов), name, onsubmit/onreset (обработчик события submit/reset для скриптов), accept-character.  
它使用 <form> 标签进行设置，可以包含以下属性：action，包含表单处理程序的 URI（必需属性）、method（默认为 GET）、enctype（编码类型）、accept（文件上传的 MIME 类型）、name、onsubmit/onreset（脚本的提交/重置事件处理程序）、accept-character。

Виды полей:
```
Кнопка <input>. Типы кнопок <submit>, <image>, <reset>, <button>.
Checkbox.
Radio.
Select.
Text и многострочный textarea.
Password.
Hidden (скрытое поле).
File.
```

5. Каскадные таблицы стилей (CSS). Структура - правила, селекторы. Виды селекторов, особенности их применения. Приоритеты правил. Преимущества CSS перед непосредственным заданием стилей через атрибуты тегов.
级联样式表 （CSS）。结构 - 规则、选择器。选择器的类型，其应用程序的功能。规则优先级。CSS 相对于直接通过标签属性设置样式的优势。  

CSS - формальный язык описания внешнего вида документа с помощью языка разметки.  
CSS 是一种使用标记语言描述文档外观的正式语言。  

CSS-правило - блок, который состоит из селектора и блока объявления стилей.  
CSS 规则是由选择器和样式声明块组成的块。  

Селекторы - имя тега, к которому применяется правило.  
选择器——规则适用的标签的名称。  

Основные виды селекторов:  
主要的选择器类型：  
* - любые элементы
div элементы с тегом div
#id - элемент по id
.class - элементы с классом class
[name="value"] - селекторы по атрибуту
:visited - псевдоклассы
div p - элементы p, являющиеся потомками div
div > p – только непосредственные потомки
div ~ p – правые соседи: все p на том же уровне вложенности, которые идут после div
div + p – первый правый сосед: p на том же уровне вложенности, который идёт сразу после div
Приоритеты правил.
Самый высокий приоритет имеет атрибут `style`.
Второе по приоритету - присутствие ID в селекторе.
Все атрибуты (включая class и псевдоклассы)
Самый низкий - селекторы с именами элементов и псевдоэлементами.
!important позволяет повысить приоритет стиля.  
带有 div 标签的 div 元素
#id - 按 ID 筛选元素
.class - 带有 class 的元素
[name="value"] - 按属性筛选选择器
:visited - 伪类
div p - div 的后代元素 p
div > p - 仅限其直系后代
div ~ p - 右邻元素：div 之后所有处于同一嵌套级别的 p
div + p - 第一个右邻元素：div 之后所有处于同一嵌套级别的 p
规则优先级：
样式属性具有最高优先级。
第二高优先级是选择器中存在 ID。
所有属性（包括 class 和伪类）
最低优先级 - 带有元素名称和伪元素的选择器。
!important 可用于提高样式的优先级。  

6. LESS, Sass, SCSS. Ключевые особенности, сравнительные характеристики. Совместимость с браузерами, трансляция в "обычный" CSS.
LESS, Sass, CSS. 主要特征，比较特征。浏览器兼容性，翻译为“常规”CSS。  

LESS - это динамический язык стилей, который является надстройкой над CSS (Поэтому любой CSS код будет валидный LESS).  
LESS 是一种动态样式语言，它是 CSS 的上层结构（因此任何 CSS 代码在 LESS 中都是有效的）。  

Приемущества LESS:  
LESS的优势：  

Переменные (и области видимости переменных).
Операции (в том числе и для управления цветом, т.е можно смешивать цвета: #941f1f + #222222).
И другие функции для работы с цветом (осветление, затемнение и т.п.)
Вложенность (можно вложить одно правило в другое, article.post p {} <=> article.post { p{   }}).
Объединение аргуметов.
LESS-файл конвертируется в CSS при помощи js (для этого необходимо скачать less.js с сайта LESS).  
变量（和变量作用域）。
操作（包括颜色管理，例如，您可以混合颜色：#941f1f + #222222）。
以及其他用于处理颜色的函数（例如，变亮、变暗等）。
嵌套（您可以将一个规则嵌套在另一个规则中，例如，article.post p {} <=> article.post { p{ }}）。
合并参数。
LESS 文件使用 JS 转换为 CSS（为此，您需要从 LESS 网站下载 less.js）。
``` 
<script src="less.js" type="text/javascript"></script>
Затем можно привязывать файлы с расширением .less.

<link rel="stylesheet/less" type="text/css" href="style.less">
```

Sass
Sass - это метаязык на основе CSS, предназначенный для увеличения уровня абстракции CSS кода и упрощения файлов каскадных таблиц стилей.  
Sass 是一种基于 CSS 的元语言，旨在提高 CSS 代码的抽象级别并简化层叠样式表文件。  

Приемущества Sass:
Sass的优势：  

Вложенные правила.
Переменные.
Возможность создавать миксины, позволяющие создавать многоразовые CSS-правила - группы деклараций, для многократного использования. (LESS в это не может)
Расширения. Одиночный селектор может быть расширен больше, чес одним селектором с помошью @extend.  
嵌套规则。
变量。
创建混合宏 (mixin) 的功能，允许您创建可重用的 CSS 规则（声明组），以便重复使用。（LESS 无法做到这一点）
扩展。可以使用 @extend 扩展单个选择器，使其包含多个选择器。
Есть логика. (if/then/for). (Этого в LESS тоже нет)
Не может компилироватся на сервере в CSS (LESS использует js).

Браузер не распознает файлы Sass, так что сначала их нужно скомпилировать в обычный CSS.  
浏览器无法识别 Sass 文件，因此需要先将其编译为常规 CSS。
 
SCSS
SCSS — "диалект" языка SASS. Отличие SCSS от SASS заключается в том, что SCSS больше похож на обычный CSS код.  
SCSS 是 SASS 语言的一种“方言”。SCSS 与 SASS 的区别在于，SCSS 更像常规的 CSS 代码。
```
@import - @import "template" подключит template.scss.
Вложенность.
$переменные.
Математика чисел и цветов.
Строки (умеет складвать строки, поддерживает конструкцию #{$var})
```

7. Клиентские сценарии. Особенности, сферы применения. Язык JavaScript.
客户端脚本。特点，应用领域。JavaScript 语言。  

Сценарий - код, включенный в состав веб-страницы. Клиентский сценарий выполняется на компьютере-клиенте, для этого необходим встроенный интерпретатор. Вставка сценария в веб-страницу происходит при помощи тега <script>.  
脚本 - 网页中包含的代码。客户端脚本在客户端计算机上执行，因此需要内置解释器。使用 <script> 标签可以将脚本插入网页。

JavaScript является объектно-ориентированным языком. JavaScript имеет ряд свойств, присущих функциональным языкам — функции как объекты первого класса, объекты как списки, карринг, анонимные функции, замыкания. Js имеет автоматическое приведение типов, автоматическая сборка мусора, анонимные функции, функции как объекты первого класса (т.е. мб сохранены в переменную, переданны в функцию как аргумент, созданы во время выполнения программы и т.п.)  
JavaScript 是一种面向对象的语言。JavaScript 具有许多函数式语言固有的特性——函数作为一等对象、对象作为列表、柯里化、匿名函数和闭包。JS 还具有自动类型转换、自动垃圾收集、匿名函数、函数作为一等对象（即，MB 保存在变量中、作为参数传递给函数、在程序执行期间创建等）等特性。  

Основные архитектурные черты:

динамическая типизация;
слабая типизация;
автоматическое управление памятью;
прототипное программирование;
функции как объекты первого класса.
Типы данных  
动态类型；
弱类型；
自动内存管理；
原型编程；
函数作为一等对象。
数据类型
number -- целые, дробные числа, Infinity, NaN
String
boolean
null
undefined -- «значение не присвоено»
object -- для коллекций и более сложных сущностей
8. Версии ECMAScript, новые возможности ES6 и ES7.
ECMAScript 版本，ES6 和 ES7 中的新功能。  

ECMAScript — это встраиваемый расширяемый не имеющий средств ввода-вывода язык программирования, используемый в качестве основы для построения других скриптовых языков. Стандартизирован международной организацией ECMA в спецификации. (ECMAScript это стандарт, а JavaScript его реализация).  
ECMAScript 是一种可嵌入、可扩展、无 I/O 的编程语言，可作为构建其他脚本语言的基础。它由国际组织 ECMA 制定了标准化规范。（ECMAScript 是标准，JavaScript 是其实现。）

Имеет 5 примитивных типов данных — Number, String, Boolean, Null и Undefined; Объектный тип данных — Object и 15 различных видов инструкций.  
它有5种原始数据类型——Number、String、Boolean、Null和Undefined；对象数据类型——Object和15种不同类型的指令。  

ES6
Это обновление добавило новый синтаксис для написания классов и модулей, добавились итераторы и циклы for/of, Python-style генераторы, двоичные данные, лямбда-выражения, типизированные массивы, коллекции, обещания (promises), рефлексию и прокси, усовершенствовали числа и математику. Добавлено ключевое слово let (которое помогает объявить переменной область видимости - блок) и const.  
本次更新添加了用于编写类和模块、迭代器和 for/of 循环、Python 风格生成器、二进制数据、lambda 表达式、类型数组、集合、promise、反射和代理的新语法，并改进了数字和数学运算。新增了 let 关键字（用于声明变量的作用域 - 块）和 const。

ES7
Добавлена операция возведения в степень (**), Array.prototype.includes().

9. Синхронная и асинхронная обработка HTTP-запросов. AJAX.
HTTP 请求的同步和异步处理。AJAX。  
Синхронный запрос - запрос с ожидением ответа. (скрипт послал запрос (объект) на сервер и ждет ответ).  
同步请求 - 期望得到响应的请求。（脚本向服务器发送了一个请求（对象），并正在等待响应）。  

Асинхронный запрос - запрос без ожидания ответа от сервера. (скрипт послал запрос (объект) на сервер, но продолжает выполняться, когда данные вернутся вступает в дело событие onreadystatechenge. Сам объект меняет это событие, когда у него меняется свойство readyState. Для события создается собственная функция, в которой проверяется свойство readyState. И как только оно становится равным "4" - это значит, что данные с сервера пришли. Теперь можно полученные данные обрабатывать).  
异步请求 - 不等待服务器响应的请求。（脚本向服务器发送了一个请求（对象），但继续执行，当数据返回时，onreadystatechange 事件就会生效。当对象的 readyState 属性发生变化时，该事件也会随之改变。为此事件创建一个单独的函数，用于检查 readyState 属性。一旦该属性等于“4”，就表示服务器的数据已到达。现在就可以处理接收到的数据了。  

```js
   var request = getXmlHttpRequest(); // создание объекта
   request.onreadystatechenge = function(){ // установка обработчика onreadystatechenge и проверка свойства readyState
       if(request.readyState == 4)
       ...
   }
   request.open('GET', url, true); // готовим запрос
   request.send(null); // посылаем запрос
```

AJAX
Asynchronous Javascript and XML - подход к построению интерактивных пользовательских интерфейсов веб-приложений, заключающийся в «фоновом» обмене данными браузера с веб-сервером.  
异步 Javascript 和 XML 是一种为 Web 应用程序构建交互式用户界面的方法，涉及浏览器和 Web 服务器之间的“后台”数据交换。  

Пользователь что-то делает -> скрипт определяет с чем там надо работать -> браузер отправляет запрос на сервер -> сервер возвращает только то, от чего ожидаются изменения -> скрипт вносит изменения обратно (без перезагрузки страницы).  
用户执行某些操作 -> 脚本确定需要处理的内容 -> 浏览器向服务器发送请求 -> 服务器仅返回预期更改的内容 -> 脚本进行更改（无需重新加载页面）。  

10. Библиотека jQuery. Назначение, основные API. Использование для реализации AJAX и работы с DOM.
jQuery 库。目的，主要 API。用于 AJAX 实现和 与DOM工作。  

jQuery - библиотека js, помогающая легко получить доступ к любому элементу DOM и манипулировать ими, предоставляет API для работы с AJAX.  
jQuery 是一个 js 库，可以帮助您轻松访问和操作任何 DOM 元素，并提供了与 AJAX 配合使用的 API。

jQuery включается в страницу как внешний файл.  
jQuery 作为外部文件包含在页面中。

`<script src="jquery-2.2.2.min.js">`

Вся работа с jQuery ведется с помощью функции $. Работу с jQuery можно разделить на 2 типа:

Получение jQuery-объекта с помощью функции $().
Вызов глобальных методов у объекта $.
Типичный пример манипуляции сразу несколькими узлами DOM заключается в вызове $ функции со строкой селектора CSS, что возвращает объект jQuery, содержащий некоторое количество элементов HTML-страницы. Эти элементы затем обрабатываются методами jQuery.  
使用 $() 函数获取 jQuery 对象。
在 $ 对象上调用全局方法。
一次操作多个 DOM 节点的一个常见示例是使用 CSS 选择器字符串调用 $ 函数，该函数返回一个包含多个 HTML 页面元素的 jQuery 对象。然后，这些元素将由 jQuery 方法进行处理。  

```js
$("div.test").add("p.quote").addClass("blue").slideDown("slow");
//находит элементы div с классом test, все элементы p с классом quote, добавляет им класс blue, ...
$.ajax и соответствующие функции позволяют использовать методы AJAX

$.ajax({
  type: "POST",
  url: "some.php",      // обращение к some.php
  data: {name: 'John', location: 'Boston'},   //с какими-то параметрами
  success: function(msg){
    alert( "Data Saved: " + msg );  // получный результат выводится в alert
  }
}); 
```

11. Реализация AJAX с помощью SuperAgent.
使用 SuperAgent 实现 AJAX。  
SuperAgent - API для реализации AJAX:  
SuperAgent - 用于 AJAX 实现的 API：  

```
request
  .post('/api/pet')
  .send({ name: 'Manny', species: 'cat' })
  .set('X-API-Key', 'foobar')
  .set('Accept', 'application/json')
  .end(function(err, res){
  if (err || !res.ok) {
    alert('Oh no! Error');
  } else {
    alert('yay got ' + JSON.stringify(res.body));
  }
});
```

12. Серверные сценарии. CGI - определение, назначение, ключевые особенности.
服务器脚本。CGI - 定义、目的、主要特征。  
CGI (Common Gateway Interface — общий интерфейс шлюза) — стандарт интерфейса, используемого для связи внешней программы с веб-сервером. Программу, которая работает по такому интерфейсу совместно с веб-сервером, принято называть шлюзом (оно же скрипт или CGI-программа). По сути позволяет использовать консоль ввода и вывода для взаимодействия с клиентом.  
CGI（通用网关接口）是一种用于将外部程序连接到 Web 服务器的接口标准。与 Web 服务器协同运行在这种接口上的程序通常被称为网关（也称为脚本或 CGI 程序）。本质上，它允许您使用输入输出控制台与客户端进行交互。

CGI - сценарии

CGI — механизм вызова пользователем программ на стороне сервера.
Данные отправляются программе посредством HTTP-запроса, формируемого веб-браузером.
То, какая именно программа будет вызвана, обычно определяется URL запроса.
Каждый запрос обрабатывается отдельным процессом CGI-программы.
Взаимодействие программы с веб-сервером осуществляется через stdin и stdout.  
CGI 是一种用户调用服务器端程序的机制。
数据通过 Web 浏览器生成的 HTTP 请求发送到程序。
通常由请求 URL 确定要调用的具体程序。
每个请求由一个单独的 CGI 程序进程处理。
程序通过标准输入 (stdin) 和标准输出 (stdout) 与 Web 服务器交互。  

13. FastCGI - особенности технологии, преимущества и недостатки относительно CGI.
FastCGI - 该技术的特点，与 CGI 相比的优缺点。
FastCGI – это высокопроизводительный протокол взаимодействия между веб-сервером и приложениями.  
FastCGI 是一种用于 Web 服务器和应用程序之间通信的高性能协议  
Его главная особенность – поддержание постоянно запущенных процессов (демонов), обрабатывающих множество запросов последовательно, в отличие от CGI, который перезапускает процесс для каждого запроса, что снижает накладные расходы и повышает производительность.   
它的主要特点是它维护持续运行的进程（守护进程），按顺序处理许多请求，这与 CGI 不同，CGI 会为每个请求重新启动进程，从而减少开销并提高性能。  

14.  FastCGI сервер на языке Java.
Java 中的 FastCGI 服务器。  
FastCGI сервер на языке Java может быть реализован с использованием библиотек, предоставляющих FastCGI-клиентскую часть и позволяющих взаимодействовать с веб-сервером, таким как Apache, через внешний процесс FastCGI. Этот подход позволяет Java-приложениям выступать в роли обработчиков запросов для веб-сервера.  
Java 中的 FastCGI 服务器可以使用提供 FastCGI 客户端并允许通过外部 FastCGI 进程与 Apache 等 Web 服务器进行通信的库来实现。  

Небольшая сводка по тому как вообще устроен CGI. В CGI используется понятие веб-сервера и серверного сценария, написанного на произвольном ЯП. Веб-сервер при обработке запроса запускает CGI процесс серверного сценария и при помощи stdin/stdout общается с прикладной программой. Очевидным недостатком такого подхода являются высокие накладные расходы на запуск отдельного процесса под обработку каждого запроса.  
CGI 一般工作原理的简短总结。CGI 使用 Web 服务器和用任意语言编写的服务器脚本的概念。在处理请求时，Web 服务器启动服务器脚本的 CGI 进程，并使用 stdin/stdout 与应用程序进行通信。这种方法的明显缺点是运行单独的进程来处理每个请求的开销成本很高。  
FastCGI стал развитием CGI в сторону оптимизации. Так, в FastCGI веб-сервер запускает пулл FastCGI процессов и общается с ними при помощи Unix sockets или TCP/IP sockets. Альтернативным вариантом может быть также внешний по отношении к веб-серверу FastCGI сервер. За счет поддержания постоянно запущенных процессов для обработки запросов снижаются накладные расходы. К тому же, так как появилась возможность использования внешного FastCGI сервера - стало возможным распределять обработку по нескольким узлам, что так же повышает потенциальную пропускную способность подобного решения.   
FastCGI 是 CGI 向优化的演变。例如，在 FastCGI 中，Web 服务器运行 FastCGI 进程拉取并使用 Unix 套接字或 TCP/IP 套接字与它们通信。或者，您也可以在 FastCGI Web 服务器外部设置服务器。通过维护持续运行的处理请求的流程，可以降低间接成本。此外，由于可以使用外部 FastCGI 服务器，因此可以在多个节点之间分配处理，这也增加了此类解决方案的潜在吞吐量。  






### Вопросы к защите
1. CORS
Политика same-origin, которую браузеры распространяют на запросы из JS (fetch()), клиент не может запросить ресурсы с другого origin'а (origin = домен (example.com), протокол (http/https), порт (80)).

Cross-origin resource sharing позволяет запросить ресурсы (картинки, CSS, JS) не со своего origin'а. Сначала клиент отправляет HTTP OPTIONS запрос с заголовком Origin: http://www.example.com, где example.com — адрес сайта. Если сервер не позволяет получить ресурс, возвращается страница ошибки, иначе — заголовок Access-Control-Allow-Origin: ..., который может вместо ... включать адрес запросившего сайта (http://www.example.com) или *.

Сервер может вернуть заголовок Access-Control-Allow-Methods: GET, POST, ..., в котором перечисляются возможные методы для доступа к ресурсу.

Сервер может вернуть заголовок Access-Control-Allow-Credentials: true, чтобы указать, что клиент может отправлять cookies вместе с запросом.

2. HTTPS
HTTPS позволяет общаться с сервером по зашифрованному каналу, что предотвращает утечку секретов (паролей) и атаки man-in-the-middle (злоумышленник меняет данные, которые передаются между клиентом и сервером).

Шифруется все, что передается в запросе (URL запроса, заголовки, тело). Сервер предоставляет сертификат, который подтверждает его identity (сертификат должен быть издан доверенным лицом — обычно компанией, ключ которой браузеры признают как доверенный). Таким образом, сервер подтверждает, что он является тем, за кого себя выдает — не фишинг-сайтом и не "человеком посредине".

3. ООП в JS
В JavaScript у объектов есть прототипы. Экземпляр объекта содержит ссылку на его прототип, который содержит ссылку на прототип прототипа — до Object.

Конструктор объявляется как функцией, this является в ней экземпляром объекта:

function Person(name) {
  this.name = name;
  this.greeting = function() {
    alert('Hi! I\'m ' + this.name + '.');
  };
}
Функции прототипа объявляются отдельно:

Person.prototype.fun = function() { ... }
this
this в JavaScript зависит от того, как вызывается функция. Он может быть

Вне функции, this — объект window. Внутри функции, он равен undefined, если не задан:

function f(arg) { ... }
f(1); // this === undefined, arg === 1
f.call(2, 1); // this === 2, arg === 1
Метод bind создают новую функцию, переопределяя в ней this:

function f() { ... }
f(); // this === undefined
var newF = f.bind(3);
newF(); // this === 3
При вызове функции у экземпляра объекта, this становится равен экземпляру.

ES6
class Foo {} транслируется в function Foo(), т.е. функцию конструктора. При этом тело конструктора объявляется внутри класса:

class Foo {
  constructor(arg1, arg2) {
    this.something = arg1 + arg2;
  }
}
Классы могут быть наследованы:

class Foo extends Bar {
  constructor() {
    super(..); // возможно вызвать constructor у Bar
  }
}
4. CSS-анимация
Все современные браузеры поддерживают CSS transitions и CSS animations, которые позволяют реализовывать анимацию срадствами CSS.

CSS transitions: указываем некоторое свойство, которое будет анимироваться при помощи SCC-правил. Далее, при изменении этого свойства браузер сам будет обрабатывать анимацию.

Есть 5 свойств, задающих анимацию:

transition-property - устанавливает свойство для эффекта перехода.
transition-duration - задает время, которое будет длиться анимация.
transition-timing-function - математическая функция, указывающая с какой скоростью в зависимости от времени меняется значение свойства.
transition-delay - время ожидания перед запуском эффекта.
transitionend - событие после выполнения SCC transition.
CSS animations: более сложные анимации можно сделать объединением простых при помощи CSS-правила @keyframes. В нем задается имя анимации и правила, по которым нужно анимировать. Потом анимацию можно подключить с помощью свойства animation.

5. Наследование в SCC. Что наследуется, что нет?
Наследуемые свойства: border-collapse, border-spacing, caption-side, color, cursor, direction, font и его свита (размер, стиль...), letter-spacing, line-height, list-style (и его свита тоже), pitch-range, pitch, text-indent, text-transform, white-space, widows, word-spacing

Остальные свойства являются ненаследуемыми.

С помощью inherit можно указать, чтобы элемент наследовал значение у своего предка. initial - запрещает наследование (и устанавливает исходное значение).

6. Веб-сервер и сервер приложений
Веб-сервер — сервер, принимающий HTTP-запросы от клиентов (обычно веб-браузеров), и выдающий им HTTP-ответы, вместе с HTML-страницей, изображениями, файлами и другими данными.

Сервер приложений — программная платформа (фреймворк), предназначенная для эффективного исполнения программ/скриптов, на которых построены приложения. Сервер приложений действует как набор компонентов, доступных разработчику программного обеспечения через API.

Для веб-приложений основная задача компонентов сервера — обеспечивать создание динамических страниц.

7. Как выглядят HTTP-запросы
application/x-www-form-urlencoded: значения кодируются в кортежах с ключом, разделенных символом '&', с '=' между ключом и значением.
POST / HTTP/1.1
Host: foo.com
Content-Type: application/x-www-form-urlencoded
Content-Length: 13

say=Hi&to=Mom
multipart/form-data
POST /test.html HTTP/1.1 
Host: example.org 
Content-Type: multipart/form-data;boundary="boundary" 

--boundary 
Content-Disposition: form-data; name="field1" 

value1 
--boundary 
Content-Disposition: form-data; name="field2"; filename="example.txt" 

value2
Какие символы разрешены в GET
Пробел кодируется как %20
Буквы, цифры, некоторые символы * - . _ кодируются с %2B
Для некоторых символов есть 16-ричное предстваление
~ кодируется как %7E
8. Cookie
HTTP cookie (web cookie, cookie браузера) - это небольшой фрагмент данных, отправляемый сервером на браузер пользователя, который тот может сохранить и отсылать обратно с новым запросом к данному серверу. Это позволяет узнать, с одного ли браузера пришли запросы. Они запоминают информацию о состоянии для протокола HTTP, который сам по себе этого делать не умеет.

Используется для:

Управления сеансом (логины, корзины для виртуальных покупок)
Персонализации (пользовательские предпочтения)
Мониторинга (отслеживания поведения пользователя)
Создание cookie
Получив HTTP-запрос, вместе с откликом сервер может отправить заголовок Set-Cookie с ответом. Cookie обычно запоминаются браузером и посылаются в значении заголовка HTTP Cookie с каждым новым запросом к одному и тому же серверу.


### 问题需要改进：  
1. Исправить таблицу с результатами попадания точки (либо скролл, либо пагинация)  
使用点击点的结果来修复表格（滚动或分页）  

2. 执行时间过短，需要改进
